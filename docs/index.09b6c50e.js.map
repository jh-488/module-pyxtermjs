{"mappings":"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","sources":["<anon>","node_modules/xterm-addon-search/lib/xterm-addon-search.js","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/webpack/universalModuleDefinition","node_modules/xterm-addon-search/lib/src/common/EventEmitter.ts","node_modules/xterm-addon-search/lib/src/common/Lifecycle.ts","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/webpack/bootstrap","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/src/SearchAddon.ts"],"sourcesContent":["!function(e, t) {\n    \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.SearchAddon = t() : e.SearchAddon = t();\n}(self, ()=>(()=>{\n        \"use strict\";\n        var e = {\n            345: (e, t)=>{\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.forwardEvent = t.EventEmitter = void 0, t.EventEmitter = class {\n                    constructor(){\n                        this._listeners = [], this._disposed = !1;\n                    }\n                    get event() {\n                        return this._event || (this._event = (e)=>(this._listeners.push(e), {\n                                dispose: ()=>{\n                                    if (!this._disposed) {\n                                        for(let t = 0; t < this._listeners.length; t++)if (this._listeners[t] === e) return void this._listeners.splice(t, 1);\n                                    }\n                                }\n                            })), this._event;\n                    }\n                    fire(e, t) {\n                        const i = [];\n                        for(let e = 0; e < this._listeners.length; e++)i.push(this._listeners[e]);\n                        for(let s = 0; s < i.length; s++)i[s].call(void 0, e, t);\n                    }\n                    dispose() {\n                        this.clearListeners(), this._disposed = !0;\n                    }\n                    clearListeners() {\n                        this._listeners && (this._listeners.length = 0);\n                    }\n                }, t.forwardEvent = function(e, t) {\n                    return e((e)=>t.fire(e));\n                };\n            },\n            859: (e, t)=>{\n                function i(e) {\n                    for (const t of e)t.dispose();\n                    e.length = 0;\n                }\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.getDisposeArrayDisposable = t.disposeArray = t.toDisposable = t.MutableDisposable = t.Disposable = void 0, t.Disposable = class {\n                    constructor(){\n                        this._disposables = [], this._isDisposed = !1;\n                    }\n                    dispose() {\n                        this._isDisposed = !0;\n                        for (const e of this._disposables)e.dispose();\n                        this._disposables.length = 0;\n                    }\n                    register(e) {\n                        return this._disposables.push(e), e;\n                    }\n                    unregister(e) {\n                        const t = this._disposables.indexOf(e);\n                        -1 !== t && this._disposables.splice(t, 1);\n                    }\n                }, t.MutableDisposable = class {\n                    constructor(){\n                        this._isDisposed = !1;\n                    }\n                    get value() {\n                        return this._isDisposed ? void 0 : this._value;\n                    }\n                    set value(e) {\n                        var t;\n                        this._isDisposed || e === this._value || (null === (t = this._value) || void 0 === t || t.dispose(), this._value = e);\n                    }\n                    clear() {\n                        this.value = void 0;\n                    }\n                    dispose() {\n                        var e;\n                        this._isDisposed = !0, null === (e = this._value) || void 0 === e || e.dispose(), this._value = void 0;\n                    }\n                }, t.toDisposable = function(e) {\n                    return {\n                        dispose: e\n                    };\n                }, t.disposeArray = i, t.getDisposeArrayDisposable = function(e) {\n                    return {\n                        dispose: ()=>i(e)\n                    };\n                };\n            }\n        }, t = {};\n        function i(s) {\n            var r = t[s];\n            if (void 0 !== r) return r.exports;\n            var o = t[s] = {\n                exports: {}\n            };\n            return e[s](o, o.exports, i), o.exports;\n        }\n        var s = {};\n        return (()=>{\n            var e = s;\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.SearchAddon = void 0;\n            const t = i(345), r = i(859), o = \" ~!@#$%^&*()+`-=[]{}|\\\\;:\\\"',./<>?\";\n            class n extends r.Disposable {\n                constructor(e){\n                    var i;\n                    super(), this._highlightedLines = new Set, this._highlightDecorations = [], this._selectedDecoration = this.register(new r.MutableDisposable), this._linesCacheTimeoutId = 0, this._onDidChangeResults = this.register(new t.EventEmitter), this.onDidChangeResults = this._onDidChangeResults.event, this._highlightLimit = null !== (i = null == e ? void 0 : e.highlightLimit) && void 0 !== i ? i : 1e3;\n                }\n                activate(e) {\n                    this._terminal = e, this.register(this._terminal.onWriteParsed(()=>this._updateMatches())), this.register(this._terminal.onResize(()=>this._updateMatches())), this.register((0, r.toDisposable)(()=>this.clearDecorations()));\n                }\n                _updateMatches() {\n                    var e;\n                    this._highlightTimeout && window.clearTimeout(this._highlightTimeout), this._cachedSearchTerm && (null === (e = this._lastSearchOptions) || void 0 === e ? void 0 : e.decorations) && (this._highlightTimeout = setTimeout(()=>{\n                        const e = this._cachedSearchTerm;\n                        this._cachedSearchTerm = void 0, this.findPrevious(e, Object.assign(Object.assign({}, this._lastSearchOptions), {\n                            incremental: !0,\n                            noScroll: !0\n                        }));\n                    }, 200));\n                }\n                clearDecorations(e) {\n                    this._selectedDecoration.clear(), (0, r.disposeArray)(this._highlightDecorations), this._highlightDecorations = [], this._highlightedLines.clear(), e || (this._cachedSearchTerm = void 0);\n                }\n                findNext(e, t) {\n                    if (!this._terminal) throw new Error(\"Cannot use addon until it has been loaded\");\n                    this._lastSearchOptions = t, (null == t ? void 0 : t.decorations) && (void 0 !== this._cachedSearchTerm && e === this._cachedSearchTerm || this._highlightAllMatches(e, t));\n                    const i = this._findNextAndSelect(e, t);\n                    return this._fireResults(t), this._cachedSearchTerm = e, i;\n                }\n                _highlightAllMatches(e, t) {\n                    if (!this._terminal) throw new Error(\"Cannot use addon until it has been loaded\");\n                    if (!e || 0 === e.length) return void this.clearDecorations();\n                    t = t || {}, this.clearDecorations(!0);\n                    const i = [];\n                    let s, r = this._find(e, 0, 0, t);\n                    for(; r && ((null == s ? void 0 : s.row) !== r.row || (null == s ? void 0 : s.col) !== r.col) && !(i.length >= this._highlightLimit);)s = r, i.push(s), r = this._find(e, s.col + s.term.length >= this._terminal.cols ? s.row + 1 : s.row, s.col + s.term.length >= this._terminal.cols ? 0 : s.col + 1, t);\n                    for (const e of i){\n                        const i = this._createResultDecoration(e, t.decorations);\n                        i && (this._highlightedLines.add(i.marker.line), this._highlightDecorations.push({\n                            decoration: i,\n                            match: e,\n                            dispose () {\n                                i.dispose();\n                            }\n                        }));\n                    }\n                }\n                _find(e, t, i, s) {\n                    var r;\n                    if (!this._terminal || !e || 0 === e.length) return null === (r = this._terminal) || void 0 === r || r.clearSelection(), void this.clearDecorations();\n                    if (i > this._terminal.cols) throw new Error(`Invalid col: ${i} to search in terminal of ${this._terminal.cols} cols`);\n                    let o;\n                    this._initLinesCache();\n                    const n = {\n                        startRow: t,\n                        startCol: i\n                    };\n                    if (o = this._findInLine(e, n, s), !o) for(let i = t + 1; i < this._terminal.buffer.active.baseY + this._terminal.rows && (n.startRow = i, n.startCol = 0, o = this._findInLine(e, n, s), !o); i++);\n                    return o;\n                }\n                _findNextAndSelect(e, t) {\n                    var i;\n                    if (!this._terminal || !e || 0 === e.length) return null === (i = this._terminal) || void 0 === i || i.clearSelection(), this.clearDecorations(), !1;\n                    const s = this._terminal.getSelectionPosition();\n                    this._terminal.clearSelection();\n                    let r = 0, o = 0;\n                    s && (this._cachedSearchTerm === e ? (r = s.end.x, o = s.end.y) : (r = s.start.x, o = s.start.y)), this._initLinesCache();\n                    const n = {\n                        startRow: o,\n                        startCol: r\n                    };\n                    let l = this._findInLine(e, n, t);\n                    if (!l) for(let i = o + 1; i < this._terminal.buffer.active.baseY + this._terminal.rows && (n.startRow = i, n.startCol = 0, l = this._findInLine(e, n, t), !l); i++);\n                    if (!l && 0 !== o) for(let i = 0; i < o && (n.startRow = i, n.startCol = 0, l = this._findInLine(e, n, t), !l); i++);\n                    return !l && s && (n.startRow = s.start.y, n.startCol = 0, l = this._findInLine(e, n, t)), this._selectResult(l, null == t ? void 0 : t.decorations, null == t ? void 0 : t.noScroll);\n                }\n                findPrevious(e, t) {\n                    if (!this._terminal) throw new Error(\"Cannot use addon until it has been loaded\");\n                    this._lastSearchOptions = t, (null == t ? void 0 : t.decorations) && (void 0 !== this._cachedSearchTerm && e === this._cachedSearchTerm || this._highlightAllMatches(e, t));\n                    const i = this._findPreviousAndSelect(e, t);\n                    return this._fireResults(t), this._cachedSearchTerm = e, i;\n                }\n                _fireResults(e) {\n                    if (null == e ? void 0 : e.decorations) {\n                        let e = -1;\n                        if (this._selectedDecoration.value) {\n                            const t = this._selectedDecoration.value.match;\n                            for(let i = 0; i < this._highlightDecorations.length; i++){\n                                const s = this._highlightDecorations[i].match;\n                                if (s.row === t.row && s.col === t.col && s.size === t.size) {\n                                    e = i;\n                                    break;\n                                }\n                            }\n                        }\n                        this._onDidChangeResults.fire({\n                            resultIndex: e,\n                            resultCount: this._highlightDecorations.length\n                        });\n                    }\n                }\n                _findPreviousAndSelect(e, t) {\n                    var i;\n                    if (!this._terminal) throw new Error(\"Cannot use addon until it has been loaded\");\n                    if (!this._terminal || !e || 0 === e.length) return null === (i = this._terminal) || void 0 === i || i.clearSelection(), this.clearDecorations(), !1;\n                    const s = this._terminal.getSelectionPosition();\n                    this._terminal.clearSelection();\n                    let r = this._terminal.buffer.active.baseY + this._terminal.rows - 1, o = this._terminal.cols;\n                    const n = !0;\n                    this._initLinesCache();\n                    const l = {\n                        startRow: r,\n                        startCol: o\n                    };\n                    let h;\n                    if (s && (l.startRow = r = s.start.y, l.startCol = o = s.start.x, this._cachedSearchTerm !== e && (h = this._findInLine(e, l, t, !1), h || (l.startRow = r = s.end.y, l.startCol = o = s.end.x))), h || (h = this._findInLine(e, l, t, n)), !h) {\n                        l.startCol = Math.max(l.startCol, this._terminal.cols);\n                        for(let i = r - 1; i >= 0 && (l.startRow = i, h = this._findInLine(e, l, t, n), !h); i--);\n                    }\n                    if (!h && r !== this._terminal.buffer.active.baseY + this._terminal.rows - 1) for(let i = this._terminal.buffer.active.baseY + this._terminal.rows - 1; i >= r && (l.startRow = i, h = this._findInLine(e, l, t, n), !h); i--);\n                    return this._selectResult(h, null == t ? void 0 : t.decorations, null == t ? void 0 : t.noScroll);\n                }\n                _initLinesCache() {\n                    const e = this._terminal;\n                    this._linesCache || (this._linesCache = new Array(e.buffer.active.length), this._cursorMoveListener = e.onCursorMove(()=>this._destroyLinesCache()), this._resizeListener = e.onResize(()=>this._destroyLinesCache())), window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = window.setTimeout(()=>this._destroyLinesCache(), 15e3);\n                }\n                _destroyLinesCache() {\n                    this._linesCache = void 0, this._cursorMoveListener && (this._cursorMoveListener.dispose(), this._cursorMoveListener = void 0), this._resizeListener && (this._resizeListener.dispose(), this._resizeListener = void 0), this._linesCacheTimeoutId && (window.clearTimeout(this._linesCacheTimeoutId), this._linesCacheTimeoutId = 0);\n                }\n                _isWholeWord(e, t, i) {\n                    return (0 === e || o.includes(t[e - 1])) && (e + i.length === t.length || o.includes(t[e + i.length]));\n                }\n                _findInLine(e, t, i = {}, s = !1) {\n                    var r;\n                    const o = this._terminal, n = t.startRow, l = t.startCol, h = o.buffer.active.getLine(n);\n                    if (null == h ? void 0 : h.isWrapped) return s ? void (t.startCol += o.cols) : (t.startRow--, t.startCol += o.cols, this._findInLine(e, t, i));\n                    let a = null === (r = this._linesCache) || void 0 === r ? void 0 : r[n];\n                    a || (a = this._translateBufferLineToStringWithWrap(n, !0), this._linesCache && (this._linesCache[n] = a));\n                    const [c, d] = a, _ = this._bufferColsToStringOffset(n, l), u = i.caseSensitive ? e : e.toLowerCase(), f = i.caseSensitive ? c : c.toLowerCase();\n                    let g = -1;\n                    if (i.regex) {\n                        const t = RegExp(u, \"g\");\n                        let i;\n                        if (s) for(; i = t.exec(f.slice(0, _));)g = t.lastIndex - i[0].length, e = i[0], t.lastIndex -= e.length - 1;\n                        else i = t.exec(f.slice(_)), i && i[0].length > 0 && (g = _ + (t.lastIndex - i[0].length), e = i[0]);\n                    } else s ? _ - u.length >= 0 && (g = f.lastIndexOf(u, _ - u.length)) : g = f.indexOf(u, _);\n                    if (g >= 0) {\n                        if (i.wholeWord && !this._isWholeWord(g, f, e)) return;\n                        let t = 0;\n                        for(; t < d.length - 1 && g >= d[t + 1];)t++;\n                        let s = t;\n                        for(; s < d.length - 1 && g + e.length >= d[s + 1];)s++;\n                        const r = g - d[t], l = g + e.length - d[s], h = this._stringLengthToBufferSize(n + t, r);\n                        return {\n                            term: e,\n                            col: h,\n                            row: n + t,\n                            size: this._stringLengthToBufferSize(n + s, l) - h + o.cols * (s - t)\n                        };\n                    }\n                }\n                _stringLengthToBufferSize(e, t) {\n                    const i = this._terminal.buffer.active.getLine(e);\n                    if (!i) return 0;\n                    for(let e = 0; e < t; e++){\n                        const s = i.getCell(e);\n                        if (!s) break;\n                        const r = s.getChars();\n                        r.length > 1 && (t -= r.length - 1);\n                        const o = i.getCell(e + 1);\n                        o && 0 === o.getWidth() && t++;\n                    }\n                    return t;\n                }\n                _bufferColsToStringOffset(e, t) {\n                    const i = this._terminal;\n                    let s = e, r = 0, o = i.buffer.active.getLine(s);\n                    for(; t > 0 && o;){\n                        for(let e = 0; e < t && e < i.cols; e++){\n                            const t = o.getCell(e);\n                            if (!t) break;\n                            t.getWidth() && (r += 0 === t.getCode() ? 1 : t.getChars().length);\n                        }\n                        if (s++, o = i.buffer.active.getLine(s), o && !o.isWrapped) break;\n                        t -= i.cols;\n                    }\n                    return r;\n                }\n                _translateBufferLineToStringWithWrap(e, t) {\n                    var i;\n                    const s = this._terminal, r = [], o = [\n                        0\n                    ];\n                    let n = s.buffer.active.getLine(e);\n                    for(; n;){\n                        const l = s.buffer.active.getLine(e + 1), h = !!l && l.isWrapped;\n                        let a = n.translateToString(!h && t);\n                        if (h && l) {\n                            const e = n.getCell(n.length - 1);\n                            e && 0 === e.getCode() && 1 === e.getWidth() && 2 === (null === (i = l.getCell(0)) || void 0 === i ? void 0 : i.getWidth()) && (a = a.slice(0, -1));\n                        }\n                        if (r.push(a), !h) break;\n                        o.push(o[o.length - 1] + a.length), e++, n = l;\n                    }\n                    return [\n                        r.join(\"\"),\n                        o\n                    ];\n                }\n                _selectResult(e, t, i) {\n                    const s = this._terminal;\n                    if (this._selectedDecoration.clear(), !e) return s.clearSelection(), !1;\n                    if (s.select(e.col, e.row, e.size), t) {\n                        const i = s.registerMarker(-s.buffer.active.baseY - s.buffer.active.cursorY + e.row);\n                        if (i) {\n                            const o = s.registerDecoration({\n                                marker: i,\n                                x: e.col,\n                                width: e.size,\n                                backgroundColor: t.activeMatchBackground,\n                                layer: \"top\",\n                                overviewRulerOptions: {\n                                    color: t.activeMatchColorOverviewRuler\n                                }\n                            });\n                            if (o) {\n                                const s = [];\n                                s.push(i), s.push(o.onRender((e)=>this._applyStyles(e, t.activeMatchBorder, !0))), s.push(o.onDispose(()=>(0, r.disposeArray)(s))), this._selectedDecoration.value = {\n                                    decoration: o,\n                                    match: e,\n                                    dispose () {\n                                        o.dispose();\n                                    }\n                                };\n                            }\n                        }\n                    }\n                    if (!i && (e.row >= s.buffer.active.viewportY + s.rows || e.row < s.buffer.active.viewportY)) {\n                        let t = e.row - s.buffer.active.viewportY;\n                        t -= Math.floor(s.rows / 2), s.scrollLines(t);\n                    }\n                    return !0;\n                }\n                _applyStyles(e, t, i) {\n                    e.classList.contains(\"xterm-find-result-decoration\") || (e.classList.add(\"xterm-find-result-decoration\"), t && (e.style.outline = `1px solid ${t}`)), i && e.classList.add(\"xterm-find-active-result-decoration\");\n                }\n                _createResultDecoration(e, t) {\n                    const i = this._terminal, s = i.registerMarker(-i.buffer.active.baseY - i.buffer.active.cursorY + e.row);\n                    if (!s) return;\n                    const o = i.registerDecoration({\n                        marker: s,\n                        x: e.col,\n                        width: e.size,\n                        backgroundColor: t.matchBackground,\n                        overviewRulerOptions: this._highlightedLines.has(s.line) ? void 0 : {\n                            color: t.matchOverviewRuler,\n                            position: \"center\"\n                        }\n                    });\n                    if (o) {\n                        const e = [];\n                        e.push(s), e.push(o.onRender((e)=>this._applyStyles(e, t.matchBorder, !1))), e.push(o.onDispose(()=>(0, r.disposeArray)(e)));\n                    }\n                    return o;\n                }\n            }\n            e.SearchAddon = n;\n        })(), s;\n    })());\n\n//# sourceMappingURL=index.09b6c50e.js.map\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.SearchAddon=t():e.SearchAddon=t()}(self,(()=>(()=>{\"use strict\";var e={345:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:!0}),t.forwardEvent=t.EventEmitter=void 0,t.EventEmitter=class{constructor(){this._listeners=[],this._disposed=!1}get event(){return this._event||(this._event=e=>(this._listeners.push(e),{dispose:()=>{if(!this._disposed)for(let t=0;t<this._listeners.length;t++)if(this._listeners[t]===e)return void this._listeners.splice(t,1)}})),this._event}fire(e,t){const i=[];for(let e=0;e<this._listeners.length;e++)i.push(this._listeners[e]);for(let s=0;s<i.length;s++)i[s].call(void 0,e,t)}dispose(){this.clearListeners(),this._disposed=!0}clearListeners(){this._listeners&&(this._listeners.length=0)}},t.forwardEvent=function(e,t){return e((e=>t.fire(e)))}},859:(e,t)=>{function i(e){for(const t of e)t.dispose();e.length=0}Object.defineProperty(t,\"__esModule\",{value:!0}),t.getDisposeArrayDisposable=t.disposeArray=t.toDisposable=t.MutableDisposable=t.Disposable=void 0,t.Disposable=class{constructor(){this._disposables=[],this._isDisposed=!1}dispose(){this._isDisposed=!0;for(const e of this._disposables)e.dispose();this._disposables.length=0}register(e){return this._disposables.push(e),e}unregister(e){const t=this._disposables.indexOf(e);-1!==t&&this._disposables.splice(t,1)}},t.MutableDisposable=class{constructor(){this._isDisposed=!1}get value(){return this._isDisposed?void 0:this._value}set value(e){var t;this._isDisposed||e===this._value||(null===(t=this._value)||void 0===t||t.dispose(),this._value=e)}clear(){this.value=void 0}dispose(){var e;this._isDisposed=!0,null===(e=this._value)||void 0===e||e.dispose(),this._value=void 0}},t.toDisposable=function(e){return{dispose:e}},t.disposeArray=i,t.getDisposeArrayDisposable=function(e){return{dispose:()=>i(e)}}}},t={};function i(s){var r=t[s];if(void 0!==r)return r.exports;var o=t[s]={exports:{}};return e[s](o,o.exports,i),o.exports}var s={};return(()=>{var e=s;Object.defineProperty(e,\"__esModule\",{value:!0}),e.SearchAddon=void 0;const t=i(345),r=i(859),o=\" ~!@#$%^&*()+`-=[]{}|\\\\;:\\\"',./<>?\";class n extends r.Disposable{constructor(e){var i;super(),this._highlightedLines=new Set,this._highlightDecorations=[],this._selectedDecoration=this.register(new r.MutableDisposable),this._linesCacheTimeoutId=0,this._onDidChangeResults=this.register(new t.EventEmitter),this.onDidChangeResults=this._onDidChangeResults.event,this._highlightLimit=null!==(i=null==e?void 0:e.highlightLimit)&&void 0!==i?i:1e3}activate(e){this._terminal=e,this.register(this._terminal.onWriteParsed((()=>this._updateMatches()))),this.register(this._terminal.onResize((()=>this._updateMatches()))),this.register((0,r.toDisposable)((()=>this.clearDecorations())))}_updateMatches(){var e;this._highlightTimeout&&window.clearTimeout(this._highlightTimeout),this._cachedSearchTerm&&(null===(e=this._lastSearchOptions)||void 0===e?void 0:e.decorations)&&(this._highlightTimeout=setTimeout((()=>{const e=this._cachedSearchTerm;this._cachedSearchTerm=void 0,this.findPrevious(e,Object.assign(Object.assign({},this._lastSearchOptions),{incremental:!0,noScroll:!0}))}),200))}clearDecorations(e){this._selectedDecoration.clear(),(0,r.disposeArray)(this._highlightDecorations),this._highlightDecorations=[],this._highlightedLines.clear(),e||(this._cachedSearchTerm=void 0)}findNext(e,t){if(!this._terminal)throw new Error(\"Cannot use addon until it has been loaded\");this._lastSearchOptions=t,(null==t?void 0:t.decorations)&&(void 0!==this._cachedSearchTerm&&e===this._cachedSearchTerm||this._highlightAllMatches(e,t));const i=this._findNextAndSelect(e,t);return this._fireResults(t),this._cachedSearchTerm=e,i}_highlightAllMatches(e,t){if(!this._terminal)throw new Error(\"Cannot use addon until it has been loaded\");if(!e||0===e.length)return void this.clearDecorations();t=t||{},this.clearDecorations(!0);const i=[];let s,r=this._find(e,0,0,t);for(;r&&((null==s?void 0:s.row)!==r.row||(null==s?void 0:s.col)!==r.col)&&!(i.length>=this._highlightLimit);)s=r,i.push(s),r=this._find(e,s.col+s.term.length>=this._terminal.cols?s.row+1:s.row,s.col+s.term.length>=this._terminal.cols?0:s.col+1,t);for(const e of i){const i=this._createResultDecoration(e,t.decorations);i&&(this._highlightedLines.add(i.marker.line),this._highlightDecorations.push({decoration:i,match:e,dispose(){i.dispose()}}))}}_find(e,t,i,s){var r;if(!this._terminal||!e||0===e.length)return null===(r=this._terminal)||void 0===r||r.clearSelection(),void this.clearDecorations();if(i>this._terminal.cols)throw new Error(`Invalid col: ${i} to search in terminal of ${this._terminal.cols} cols`);let o;this._initLinesCache();const n={startRow:t,startCol:i};if(o=this._findInLine(e,n,s),!o)for(let i=t+1;i<this._terminal.buffer.active.baseY+this._terminal.rows&&(n.startRow=i,n.startCol=0,o=this._findInLine(e,n,s),!o);i++);return o}_findNextAndSelect(e,t){var i;if(!this._terminal||!e||0===e.length)return null===(i=this._terminal)||void 0===i||i.clearSelection(),this.clearDecorations(),!1;const s=this._terminal.getSelectionPosition();this._terminal.clearSelection();let r=0,o=0;s&&(this._cachedSearchTerm===e?(r=s.end.x,o=s.end.y):(r=s.start.x,o=s.start.y)),this._initLinesCache();const n={startRow:o,startCol:r};let l=this._findInLine(e,n,t);if(!l)for(let i=o+1;i<this._terminal.buffer.active.baseY+this._terminal.rows&&(n.startRow=i,n.startCol=0,l=this._findInLine(e,n,t),!l);i++);if(!l&&0!==o)for(let i=0;i<o&&(n.startRow=i,n.startCol=0,l=this._findInLine(e,n,t),!l);i++);return!l&&s&&(n.startRow=s.start.y,n.startCol=0,l=this._findInLine(e,n,t)),this._selectResult(l,null==t?void 0:t.decorations,null==t?void 0:t.noScroll)}findPrevious(e,t){if(!this._terminal)throw new Error(\"Cannot use addon until it has been loaded\");this._lastSearchOptions=t,(null==t?void 0:t.decorations)&&(void 0!==this._cachedSearchTerm&&e===this._cachedSearchTerm||this._highlightAllMatches(e,t));const i=this._findPreviousAndSelect(e,t);return this._fireResults(t),this._cachedSearchTerm=e,i}_fireResults(e){if(null==e?void 0:e.decorations){let e=-1;if(this._selectedDecoration.value){const t=this._selectedDecoration.value.match;for(let i=0;i<this._highlightDecorations.length;i++){const s=this._highlightDecorations[i].match;if(s.row===t.row&&s.col===t.col&&s.size===t.size){e=i;break}}}this._onDidChangeResults.fire({resultIndex:e,resultCount:this._highlightDecorations.length})}}_findPreviousAndSelect(e,t){var i;if(!this._terminal)throw new Error(\"Cannot use addon until it has been loaded\");if(!this._terminal||!e||0===e.length)return null===(i=this._terminal)||void 0===i||i.clearSelection(),this.clearDecorations(),!1;const s=this._terminal.getSelectionPosition();this._terminal.clearSelection();let r=this._terminal.buffer.active.baseY+this._terminal.rows-1,o=this._terminal.cols;const n=!0;this._initLinesCache();const l={startRow:r,startCol:o};let h;if(s&&(l.startRow=r=s.start.y,l.startCol=o=s.start.x,this._cachedSearchTerm!==e&&(h=this._findInLine(e,l,t,!1),h||(l.startRow=r=s.end.y,l.startCol=o=s.end.x))),h||(h=this._findInLine(e,l,t,n)),!h){l.startCol=Math.max(l.startCol,this._terminal.cols);for(let i=r-1;i>=0&&(l.startRow=i,h=this._findInLine(e,l,t,n),!h);i--);}if(!h&&r!==this._terminal.buffer.active.baseY+this._terminal.rows-1)for(let i=this._terminal.buffer.active.baseY+this._terminal.rows-1;i>=r&&(l.startRow=i,h=this._findInLine(e,l,t,n),!h);i--);return this._selectResult(h,null==t?void 0:t.decorations,null==t?void 0:t.noScroll)}_initLinesCache(){const e=this._terminal;this._linesCache||(this._linesCache=new Array(e.buffer.active.length),this._cursorMoveListener=e.onCursorMove((()=>this._destroyLinesCache())),this._resizeListener=e.onResize((()=>this._destroyLinesCache()))),window.clearTimeout(this._linesCacheTimeoutId),this._linesCacheTimeoutId=window.setTimeout((()=>this._destroyLinesCache()),15e3)}_destroyLinesCache(){this._linesCache=void 0,this._cursorMoveListener&&(this._cursorMoveListener.dispose(),this._cursorMoveListener=void 0),this._resizeListener&&(this._resizeListener.dispose(),this._resizeListener=void 0),this._linesCacheTimeoutId&&(window.clearTimeout(this._linesCacheTimeoutId),this._linesCacheTimeoutId=0)}_isWholeWord(e,t,i){return(0===e||o.includes(t[e-1]))&&(e+i.length===t.length||o.includes(t[e+i.length]))}_findInLine(e,t,i={},s=!1){var r;const o=this._terminal,n=t.startRow,l=t.startCol,h=o.buffer.active.getLine(n);if(null==h?void 0:h.isWrapped)return s?void(t.startCol+=o.cols):(t.startRow--,t.startCol+=o.cols,this._findInLine(e,t,i));let a=null===(r=this._linesCache)||void 0===r?void 0:r[n];a||(a=this._translateBufferLineToStringWithWrap(n,!0),this._linesCache&&(this._linesCache[n]=a));const[c,d]=a,_=this._bufferColsToStringOffset(n,l),u=i.caseSensitive?e:e.toLowerCase(),f=i.caseSensitive?c:c.toLowerCase();let g=-1;if(i.regex){const t=RegExp(u,\"g\");let i;if(s)for(;i=t.exec(f.slice(0,_));)g=t.lastIndex-i[0].length,e=i[0],t.lastIndex-=e.length-1;else i=t.exec(f.slice(_)),i&&i[0].length>0&&(g=_+(t.lastIndex-i[0].length),e=i[0])}else s?_-u.length>=0&&(g=f.lastIndexOf(u,_-u.length)):g=f.indexOf(u,_);if(g>=0){if(i.wholeWord&&!this._isWholeWord(g,f,e))return;let t=0;for(;t<d.length-1&&g>=d[t+1];)t++;let s=t;for(;s<d.length-1&&g+e.length>=d[s+1];)s++;const r=g-d[t],l=g+e.length-d[s],h=this._stringLengthToBufferSize(n+t,r);return{term:e,col:h,row:n+t,size:this._stringLengthToBufferSize(n+s,l)-h+o.cols*(s-t)}}}_stringLengthToBufferSize(e,t){const i=this._terminal.buffer.active.getLine(e);if(!i)return 0;for(let e=0;e<t;e++){const s=i.getCell(e);if(!s)break;const r=s.getChars();r.length>1&&(t-=r.length-1);const o=i.getCell(e+1);o&&0===o.getWidth()&&t++}return t}_bufferColsToStringOffset(e,t){const i=this._terminal;let s=e,r=0,o=i.buffer.active.getLine(s);for(;t>0&&o;){for(let e=0;e<t&&e<i.cols;e++){const t=o.getCell(e);if(!t)break;t.getWidth()&&(r+=0===t.getCode()?1:t.getChars().length)}if(s++,o=i.buffer.active.getLine(s),o&&!o.isWrapped)break;t-=i.cols}return r}_translateBufferLineToStringWithWrap(e,t){var i;const s=this._terminal,r=[],o=[0];let n=s.buffer.active.getLine(e);for(;n;){const l=s.buffer.active.getLine(e+1),h=!!l&&l.isWrapped;let a=n.translateToString(!h&&t);if(h&&l){const e=n.getCell(n.length-1);e&&0===e.getCode()&&1===e.getWidth()&&2===(null===(i=l.getCell(0))||void 0===i?void 0:i.getWidth())&&(a=a.slice(0,-1))}if(r.push(a),!h)break;o.push(o[o.length-1]+a.length),e++,n=l}return[r.join(\"\"),o]}_selectResult(e,t,i){const s=this._terminal;if(this._selectedDecoration.clear(),!e)return s.clearSelection(),!1;if(s.select(e.col,e.row,e.size),t){const i=s.registerMarker(-s.buffer.active.baseY-s.buffer.active.cursorY+e.row);if(i){const o=s.registerDecoration({marker:i,x:e.col,width:e.size,backgroundColor:t.activeMatchBackground,layer:\"top\",overviewRulerOptions:{color:t.activeMatchColorOverviewRuler}});if(o){const s=[];s.push(i),s.push(o.onRender((e=>this._applyStyles(e,t.activeMatchBorder,!0)))),s.push(o.onDispose((()=>(0,r.disposeArray)(s)))),this._selectedDecoration.value={decoration:o,match:e,dispose(){o.dispose()}}}}}if(!i&&(e.row>=s.buffer.active.viewportY+s.rows||e.row<s.buffer.active.viewportY)){let t=e.row-s.buffer.active.viewportY;t-=Math.floor(s.rows/2),s.scrollLines(t)}return!0}_applyStyles(e,t,i){e.classList.contains(\"xterm-find-result-decoration\")||(e.classList.add(\"xterm-find-result-decoration\"),t&&(e.style.outline=`1px solid ${t}`)),i&&e.classList.add(\"xterm-find-active-result-decoration\")}_createResultDecoration(e,t){const i=this._terminal,s=i.registerMarker(-i.buffer.active.baseY-i.buffer.active.cursorY+e.row);if(!s)return;const o=i.registerDecoration({marker:s,x:e.col,width:e.size,backgroundColor:t.matchBackground,overviewRulerOptions:this._highlightedLines.has(s.line)?void 0:{color:t.matchOverviewRuler,position:\"center\"}});if(o){const e=[];e.push(s),e.push(o.onRender((e=>this._applyStyles(e,t.matchBorder,!1)))),e.push(o.onDispose((()=>(0,r.disposeArray)(e))))}return o}}e.SearchAddon=n})(),s})()));\n//# sourceMappingURL=xterm-addon-search.js.map","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SearchAddon\"] = factory();\n\telse\n\t\troot[\"SearchAddon\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\ninterface IListener<T, U = void> {\n  (arg1: T, arg2: U): void;\n}\n\nexport interface IEvent<T, U = void> {\n  (listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IEventEmitter<T, U = void> {\n  event: IEvent<T, U>;\n  fire(arg1: T, arg2: U): void;\n  dispose(): void;\n}\n\nexport class EventEmitter<T, U = void> implements IEventEmitter<T, U> {\n  private _listeners: IListener<T, U>[] = [];\n  private _event?: IEvent<T, U>;\n  private _disposed: boolean = false;\n\n  public get event(): IEvent<T, U> {\n    if (!this._event) {\n      this._event = (listener: (arg1: T, arg2: U) => any) => {\n        this._listeners.push(listener);\n        const disposable = {\n          dispose: () => {\n            if (!this._disposed) {\n              for (let i = 0; i < this._listeners.length; i++) {\n                if (this._listeners[i] === listener) {\n                  this._listeners.splice(i, 1);\n                  return;\n                }\n              }\n            }\n          }\n        };\n        return disposable;\n      };\n    }\n    return this._event;\n  }\n\n  public fire(arg1: T, arg2: U): void {\n    const queue: IListener<T, U>[] = [];\n    for (let i = 0; i < this._listeners.length; i++) {\n      queue.push(this._listeners[i]);\n    }\n    for (let i = 0; i < queue.length; i++) {\n      queue[i].call(undefined, arg1, arg2);\n    }\n  }\n\n  public dispose(): void {\n    this.clearListeners();\n    this._disposed = true;\n  }\n\n  public clearListeners(): void {\n    if (this._listeners) {\n      this._listeners.length = 0;\n    }\n  }\n}\n\nexport function forwardEvent<T>(from: IEvent<T>, to: IEventEmitter<T>): IDisposable {\n  return from(e => to.fire(e));\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * A base class that can be extended to provide convenience methods for managing the lifecycle of an\n * object and its components.\n */\nexport abstract class Disposable implements IDisposable {\n  protected _disposables: IDisposable[] = [];\n  protected _isDisposed: boolean = false;\n\n  /**\n   * Disposes the object, triggering the `dispose` method on all registered IDisposables.\n   */\n  public dispose(): void {\n    this._isDisposed = true;\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n    this._disposables.length = 0;\n  }\n\n  /**\n   * Registers a disposable object.\n   * @param d The disposable to register.\n   * @returns The disposable.\n   */\n  public register<T extends IDisposable>(d: T): T {\n    this._disposables.push(d);\n    return d;\n  }\n\n  /**\n   * Unregisters a disposable object if it has been registered, if not do\n   * nothing.\n   * @param d The disposable to unregister.\n   */\n  public unregister<T extends IDisposable>(d: T): void {\n    const index = this._disposables.indexOf(d);\n    if (index !== -1) {\n      this._disposables.splice(index, 1);\n    }\n  }\n}\n\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n  private _value?: T;\n  private _isDisposed = false;\n\n  /**\n   * Gets the value if it exists.\n   */\n  public get value(): T | undefined {\n    return this._isDisposed ? undefined : this._value;\n  }\n\n  /**\n   * Sets the value, disposing of the old value if it exists.\n   */\n  public set value(value: T | undefined) {\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    this._value?.dispose();\n    this._value = value;\n  }\n\n  /**\n   * Resets the stored value and disposes of the previously stored value.\n   */\n  public clear(): void {\n    this.value = undefined;\n  }\n\n  public dispose(): void {\n    this._isDisposed = true;\n    this._value?.dispose();\n    this._value = undefined;\n  }\n}\n\n/**\n * Wrap a function in a disposable.\n */\nexport function toDisposable(f: () => void): IDisposable {\n  return { dispose: f };\n}\n\n/**\n * Dispose of all disposables in an array and set its length to 0.\n */\nexport function disposeArray(disposables: IDisposable[]): void {\n  for (const d of disposables) {\n    d.dispose();\n  }\n  disposables.length = 0;\n}\n\n/**\n * Creates a disposable that will dispose of an array of disposables when disposed.\n */\nexport function getDisposeArrayDisposable(array: IDisposable[]): IDisposable {\n  return { dispose: () => disposeArray(array) };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, IDisposable, ITerminalAddon, IDecoration } from 'xterm';\nimport { EventEmitter } from 'common/EventEmitter';\nimport { Disposable, toDisposable, disposeArray, MutableDisposable } from 'common/Lifecycle';\n\nexport interface ISearchOptions {\n  regex?: boolean;\n  wholeWord?: boolean;\n  caseSensitive?: boolean;\n  incremental?: boolean;\n  decorations?: ISearchDecorationOptions;\n  noScroll?: boolean;\n}\n\ninterface ISearchDecorationOptions {\n  matchBackground?: string;\n  matchBorder?: string;\n  matchOverviewRuler: string;\n  activeMatchBackground?: string;\n  activeMatchBorder?: string;\n  activeMatchColorOverviewRuler: string;\n}\n\nexport interface ISearchPosition {\n  startCol: number;\n  startRow: number;\n}\n\nexport interface ISearchAddonOptions {\n  highlightLimit: number;\n}\n\nexport interface ISearchResult {\n  term: string;\n  col: number;\n  row: number;\n  size: number;\n}\n\ntype LineCacheEntry = [\n  /**\n   * The string representation of a line (as opposed to the buffer cell representation).\n   */\n  lineAsString: string,\n  /**\n   * The offsets where each line starts when the entry describes a wrapped line.\n   */\n  lineOffsets: number[]\n];\n\ninterface IHighlight extends IDisposable {\n  decoration: IDecoration;\n  match: ISearchResult;\n}\n\nconst NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\\\;:\"\\',./<>?';\nconst LINES_CACHE_TIME_TO_LIVE = 15 * 1000; // 15 secs\nconst DEFAULT_HIGHLIGHT_LIMIT = 1000;\n\nexport class SearchAddon extends Disposable implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n  private _cachedSearchTerm: string | undefined;\n  private _highlightedLines: Set<number> = new Set();\n  private _highlightDecorations: IHighlight[] = [];\n  private _selectedDecoration: MutableDisposable<IHighlight> = this.register(new MutableDisposable());\n  private _highlightLimit: number;\n  private _lastSearchOptions: ISearchOptions | undefined;\n  private _highlightTimeout: number | undefined;\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: LineCacheEntry[] | undefined;\n  private _linesCacheTimeoutId = 0;\n  private _cursorMoveListener: IDisposable | undefined;\n  private _resizeListener: IDisposable | undefined;\n\n  private readonly _onDidChangeResults = this.register(new EventEmitter<{ resultIndex: number, resultCount: number }>());\n  public readonly onDidChangeResults = this._onDidChangeResults.event;\n\n  constructor(options?: Partial<ISearchAddonOptions>) {\n    super();\n\n    this._highlightLimit = options?.highlightLimit ?? DEFAULT_HIGHLIGHT_LIMIT;\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    this.register(this._terminal.onWriteParsed(() => this._updateMatches()));\n    this.register(this._terminal.onResize(() => this._updateMatches()));\n    this.register(toDisposable(() => this.clearDecorations()));\n  }\n\n  private _updateMatches(): void {\n    if (this._highlightTimeout) {\n      window.clearTimeout(this._highlightTimeout);\n    }\n    if (this._cachedSearchTerm && this._lastSearchOptions?.decorations) {\n      this._highlightTimeout = setTimeout(() => {\n        const term = this._cachedSearchTerm;\n        this._cachedSearchTerm = undefined;\n        this.findPrevious(term!, { ...this._lastSearchOptions, incremental: true, noScroll: true });\n      }, 200);\n    }\n  }\n\n  public clearDecorations(retainCachedSearchTerm?: boolean): void {\n    this._selectedDecoration.clear();\n    disposeArray(this._highlightDecorations);\n    this._highlightDecorations = [];\n    this._highlightedLines.clear();\n    if (!retainCachedSearchTerm) {\n      this._cachedSearchTerm = undefined;\n    }\n  }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findNextAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _highlightAllMatches(term: string, searchOptions: ISearchOptions): void {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!term || term.length === 0) {\n      this.clearDecorations();\n      return;\n    }\n    searchOptions = searchOptions || {};\n\n    // new search, clear out the old decorations\n    this.clearDecorations(true);\n\n    const searchResultsWithHighlight: ISearchResult[] = [];\n    let prevResult: ISearchResult | undefined = undefined;\n    let result = this._find(term, 0, 0, searchOptions);\n    while (result && (prevResult?.row !== result.row || prevResult?.col !== result.col)) {\n      if (searchResultsWithHighlight.length >= this._highlightLimit) {\n        break;\n      }\n      prevResult = result;\n      searchResultsWithHighlight.push(prevResult);\n      result = this._find(\n        term,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? prevResult.row + 1 : prevResult.row,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? 0 : prevResult.col + 1,\n        searchOptions\n      );\n    }\n    for (const match of searchResultsWithHighlight) {\n      const decoration = this._createResultDecoration(match, searchOptions.decorations!);\n      if (decoration) {\n        this._highlightedLines.add(decoration.marker.line);\n        this._highlightDecorations.push({ decoration, match, dispose() { decoration.dispose(); } });\n      }\n    }\n  }\n\n  private _find(term: string, startRow: number, startCol: number, searchOptions?: ISearchOptions): ISearchResult | undefined {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return undefined;\n    }\n    if (startCol > this._terminal.cols) {\n      throw new Error(`Invalid col: ${startCol} to search in terminal of ${this._terminal.cols} cols`);\n    }\n\n    let result: ISearchResult | undefined = undefined;\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  private _findNextAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startCol = 0;\n    let startRow = 0;\n    if (prevSelectedPos) {\n      if (this._cachedSearchTerm === term) {\n        startCol = prevSelectedPos.end.x;\n        startRow = prevSelectedPos.end.y;\n      } else {\n        startCol = prevSelectedPos.start.x;\n        startRow = prevSelectedPos.start.y;\n      }\n    }\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the bottom and didn't search from the very top wrap back up\n    if (!result && startRow !== 0) {\n      for (let y = 0; y < startRow; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, wrap back and return selection if it exists.\n    if (!result && prevSelectedPos) {\n      searchPosition.startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = 0;\n      result = this._findInLine(term, searchPosition, searchOptions);\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findPreviousAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _fireResults(searchOptions?: ISearchOptions): void {\n    if (searchOptions?.decorations) {\n      let resultIndex = -1;\n      if (this._selectedDecoration.value) {\n        const selectedMatch = this._selectedDecoration.value.match;\n        for (let i = 0; i < this._highlightDecorations.length; i++) {\n          const match = this._highlightDecorations[i].match;\n          if (match.row === selectedMatch.row && match.col === selectedMatch.col && match.size === selectedMatch.size) {\n            resultIndex = i;\n            break;\n          }\n        }\n      }\n      this._onDidChangeResults.fire({ resultIndex, resultCount: this._highlightDecorations.length });\n    }\n  }\n\n  private _findPreviousAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows - 1;\n    let startCol = this._terminal.cols;\n    const isReverseSearch = true;\n\n    this._initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    let result: ISearchResult | undefined;\n    if (prevSelectedPos) {\n      searchPosition.startRow = startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = startCol = prevSelectedPos.start.x;\n      if (this._cachedSearchTerm !== term) {\n        // Try to expand selection to right first.\n        result = this._findInLine(term, searchPosition, searchOptions, false);\n        if (!result) {\n          // If selection was not able to be expanded to the right, then try reverse search\n          searchPosition.startRow = startRow = prevSelectedPos.end.y;\n          searchPosition.startCol = startCol = prevSelectedPos.end.x;\n        }\n      }\n    }\n\n    if (!result) {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows - 1)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows - 1); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    const terminal = this._terminal!;\n    if (!this._linesCache) {\n      this._linesCache = new Array(terminal.buffer.active.length);\n      this._cursorMoveListener = terminal.onCursorMove(() => this._destroyLinesCache());\n      this._resizeListener = terminal.onResize(() => this._destroyLinesCache());\n    }\n\n    window.clearTimeout(this._linesCacheTimeoutId);\n    this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = undefined;\n    if (this._cursorMoveListener) {\n      this._cursorMoveListener.dispose();\n      this._cursorMoveListener = undefined;\n    }\n    if (this._resizeListener) {\n      this._resizeListener.dispose();\n      this._resizeListener = undefined;\n    }\n    if (this._linesCacheTimeoutId) {\n      window.clearTimeout(this._linesCacheTimeoutId);\n      this._linesCacheTimeoutId = 0;\n    }\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly\n   * adjacent to it.\n   * @param searchIndex starting indext of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return ((searchIndex === 0) || (NON_WORD_CHARACTERS.includes(line[searchIndex - 1]))) &&\n      (((searchIndex + term.length) === line.length) || (NON_WORD_CHARACTERS.includes(line[searchIndex + term.length])));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line,\n   * which may contain subsequent terminal lines if the text is wrapped. If the provided line number\n   * is part of a wrapped text line that started on an earlier line then it is skipped since it will\n   * be properly searched when the terminal line that the text starts on is searched.\n   * @param term The search term.\n   * @param searchPosition The position to start the search.\n   * @param searchOptions Search options.\n   * @param isReverseSearch Whether the search should start from the right side of the terminal and\n   * search to the left.\n   * @returns The search result if it was found.\n   */\n  protected _findInLine(term: string, searchPosition: ISearchPosition, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult | undefined {\n    const terminal = this._terminal!;\n    const row = searchPosition.startRow;\n    const col = searchPosition.startCol;\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    const firstLine = terminal.buffer.active.getLine(row);\n    if (firstLine?.isWrapped) {\n      if (isReverseSearch) {\n        searchPosition.startCol += terminal.cols;\n        return;\n      }\n\n      // This will iterate until we find the line start.\n      // When we find it, we will search using the calculated start column.\n      searchPosition.startRow--;\n      searchPosition.startCol += terminal.cols;\n      return this._findInLine(term, searchPosition, searchOptions);\n    }\n    let cache = this._linesCache?.[row];\n    if (!cache) {\n      cache = this._translateBufferLineToStringWithWrap(row, true);\n      if (this._linesCache) {\n        this._linesCache[row] = cache;\n      }\n    }\n    const [stringLine, offsets] = cache;\n\n    const offset = this._bufferColsToStringOffset(row, col);\n    const searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n    const searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, 'g');\n      let foundTerm: RegExpExecArray | null;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..offset\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, offset))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(offset));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = offset + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (offset - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, offset - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, offset);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple\n      // rows\n      let startRowOffset = 0;\n      while (startRowOffset < offsets.length - 1 && resultIndex >= offsets[startRowOffset + 1]) {\n        startRowOffset++;\n      }\n      let endRowOffset = startRowOffset;\n      while (endRowOffset < offsets.length - 1 && resultIndex + term.length >= offsets[endRowOffset + 1]) {\n        endRowOffset++;\n      }\n      const startColOffset = resultIndex - offsets[startRowOffset];\n      const endColOffset = resultIndex + term.length - offsets[endRowOffset];\n      const startColIndex = this._stringLengthToBufferSize(row + startRowOffset, startColOffset);\n      const endColIndex = this._stringLengthToBufferSize(row + endRowOffset, endColOffset);\n      const size = endColIndex - startColIndex + terminal.cols * (endRowOffset - startRowOffset);\n\n      return {\n        term,\n        col: startColIndex,\n        row: row + startRowOffset,\n        size\n      };\n    }\n  }\n\n  private _stringLengthToBufferSize(row: number, offset: number): number {\n    const line = this._terminal!.buffer.active.getLine(row);\n    if (!line) {\n      return 0;\n    }\n    for (let i = 0; i < offset; i++) {\n      const cell = line.getCell(i);\n      if (!cell) {\n        break;\n      }\n      // Adjust the searchIndex to normalize emoji into single chars\n      const char = cell.getChars();\n      if (char.length > 1) {\n        offset -= char.length - 1;\n      }\n      // Adjust the searchIndex for empty characters following wide unicode\n      // chars (eg. CJK)\n      const nextCell = line.getCell(i + 1);\n      if (nextCell && nextCell.getWidth() === 0) {\n        offset++;\n      }\n    }\n    return offset;\n  }\n\n  private _bufferColsToStringOffset(startRow: number, cols: number): number {\n    const terminal = this._terminal!;\n    let lineIndex = startRow;\n    let offset = 0;\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (cols > 0 && line) {\n      for (let i = 0; i < cols && i < terminal.cols; i++) {\n        const cell = line.getCell(i);\n        if (!cell) {\n          break;\n        }\n        if (cell.getWidth()) {\n          // Treat null characters as whitespace to align with the translateToString API\n          offset += cell.getCode() === 0 ? 1 : cell.getChars().length;\n        }\n      }\n      lineIndex++;\n      line = terminal.buffer.active.getLine(lineIndex);\n      if (line && !line.isWrapped) {\n        break;\n      }\n      cols -= terminal.cols;\n    }\n    return offset;\n  }\n\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param lineIndex The index of the line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  private _translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): LineCacheEntry {\n    const terminal = this._terminal!;\n    const strings = [];\n    const lineOffsets = [0];\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (line) {\n      const nextLine = terminal.buffer.active.getLine(lineIndex + 1);\n      const lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      let string = line.translateToString(!lineWrapsToNext && trimRight);\n      if (lineWrapsToNext && nextLine) {\n        const lastCell = line.getCell(line.length - 1);\n        const lastCellIsNull = lastCell && lastCell.getCode() === 0 && lastCell.getWidth() === 1;\n        // a wide character wrapped to the next line\n        if (lastCellIsNull && nextLine.getCell(0)?.getWidth() === 2) {\n          string = string.slice(0, -1);\n        }\n      }\n      strings.push(string);\n      if (lineWrapsToNext) {\n        lineOffsets.push(lineOffsets[lineOffsets.length - 1] + string.length);\n      } else {\n        break;\n      }\n      lineIndex++;\n      line = nextLine;\n    }\n    return [strings.join(''), lineOffsets];\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @returns Whether a result was selected.\n   */\n  private _selectResult(result: ISearchResult | undefined, options?: ISearchDecorationOptions, noScroll?: boolean): boolean {\n    const terminal = this._terminal!;\n    this._selectedDecoration.clear();\n    if (!result) {\n      terminal.clearSelection();\n      return false;\n    }\n    terminal.select(result.col, result.row, result.size);\n    if (options) {\n      const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n      if (marker) {\n        const decoration = terminal.registerDecoration({\n          marker,\n          x: result.col,\n          width: result.size,\n          backgroundColor: options.activeMatchBackground,\n          layer: 'top',\n          overviewRulerOptions: {\n            color: options.activeMatchColorOverviewRuler\n          }\n        });\n        if (decoration) {\n          const disposables: IDisposable[] = [];\n          disposables.push(marker);\n          disposables.push(decoration.onRender((e) => this._applyStyles(e, options.activeMatchBorder, true)));\n          disposables.push(decoration.onDispose(() => disposeArray(disposables)));\n          this._selectedDecoration.value = { decoration, match: result, dispose() { decoration.dispose(); } };\n        }\n      }\n    }\n\n    if (!noScroll) {\n      // If it is not in the viewport then we scroll else it just gets selected\n      if (result.row >= (terminal.buffer.active.viewportY + terminal.rows) || result.row < terminal.buffer.active.viewportY) {\n        let scroll = result.row - terminal.buffer.active.viewportY;\n        scroll -= Math.floor(terminal.rows / 2);\n        terminal.scrollLines(scroll);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Applies styles to the decoration when it is rendered.\n   * @param element The decoration's element.\n   * @param borderColor The border color to apply.\n   * @param isActiveResult Whether the element is part of the active search result.\n   * @returns\n   */\n  private _applyStyles(element: HTMLElement, borderColor: string | undefined, isActiveResult: boolean): void {\n    if (!element.classList.contains('xterm-find-result-decoration')) {\n      element.classList.add('xterm-find-result-decoration');\n      if (borderColor) {\n        element.style.outline = `1px solid ${borderColor}`;\n      }\n    }\n    if (isActiveResult) {\n      element.classList.add('xterm-find-active-result-decoration');\n    }\n  }\n\n  /**\n   * Creates a decoration for the result and applies styles\n   * @param result the search result for which to create the decoration\n   * @param options the options for the decoration\n   * @returns the {@link IDecoration} or undefined if the marker has already been disposed of\n   */\n  private _createResultDecoration(result: ISearchResult, options: ISearchDecorationOptions): IDecoration | undefined {\n    const terminal = this._terminal!;\n    const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n    if (!marker) {\n      return undefined;\n    }\n    const findResultDecoration = terminal.registerDecoration({\n      marker,\n      x: result.col,\n      width: result.size,\n      backgroundColor: options.matchBackground,\n      overviewRulerOptions: this._highlightedLines.has(marker.line) ? undefined : {\n        color: options.matchOverviewRuler,\n        position: 'center'\n      }\n    });\n    if (findResultDecoration) {\n      const disposables: IDisposable[] = [];\n      disposables.push(marker);\n      disposables.push(findResultDecoration.onRender((e) => this._applyStyles(e, options.matchBorder, false)));\n      disposables.push(findResultDecoration.onDispose(() => disposeArray(disposables)));\n    }\n    return findResultDecoration;\n  }\n}\n"],"names":["e","t","self","Object","defineProperty","value","forwardEvent","EventEmitter","constructor","_listeners","_disposed","event","_event","push","dispose","length","splice","fire","i","s","call","clearListeners","getDisposeArrayDisposable","disposeArray","toDisposable","MutableDisposable","Disposable","_disposables","_isDisposed","register","unregister","indexOf","_value","clear","r","exports","o","SearchAddon","n","_highlightedLines","Set","_highlightDecorations","_selectedDecoration","_linesCacheTimeoutId","_onDidChangeResults","onDidChangeResults","_highlightLimit","highlightLimit","activate","_terminal","onWriteParsed","_updateMatches","onResize","clearDecorations","_highlightTimeout","window","clearTimeout","_cachedSearchTerm","_lastSearchOptions","decorations","setTimeout","findPrevious","assign","incremental","noScroll","findNext","Error","_highlightAllMatches","_findNextAndSelect","_fireResults","_find","row","col","term","cols","_createResultDecoration","add","marker","line","decoration","match","clearSelection","_initLinesCache","startRow","startCol","_findInLine","buffer","active","baseY","rows","getSelectionPosition","end","x","y","start","l","_selectResult","_findPreviousAndSelect","size","resultIndex","resultCount","h","Math","max","_linesCache","Array","_cursorMoveListener","onCursorMove","_destroyLinesCache","_resizeListener","_isWholeWord","includes","getLine","isWrapped","a","_translateBufferLineToStringWithWrap","c","d","_","_bufferColsToStringOffset","u","caseSensitive","toLowerCase","f","g","regex","RegExp","exec","slice","lastIndex","lastIndexOf","wholeWord","_stringLengthToBufferSize","getCell","getChars","getWidth","getCode","translateToString","join","select","registerMarker","cursorY","registerDecoration","width","backgroundColor","activeMatchBackground","layer","overviewRulerOptions","color","activeMatchColorOverviewRuler","onRender","_applyStyles","activeMatchBorder","onDispose","viewportY","floor","scrollLines","classList","contains","style","outline","matchBackground","has","matchOverviewRuler","position","matchBorder","module","define","amd","root","factory","this","listener","arg1","arg2","queue","undefined","from","to","disposables","index","array","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","NON_WORD_CHARACTERS","options","super","terminal","retainCachedSearchTerm","searchOptions","found","searchResultsWithHighlight","prevResult","result","searchPosition","prevSelectedPos","selectedMatch","isReverseSearch","searchIndex","firstLine","cache","stringLine","offsets","offset","searchTerm","searchStringLine","searchRegex","foundTerm","startRowOffset","endRowOffset","startColOffset","endColOffset","startColIndex","cell","char","nextCell","lineIndex","trimRight","strings","lineOffsets","nextLine","lineWrapsToNext","string","lastCell","scroll","element","borderColor","isActiveResult","findResultDecoration"],"version":3,"file":"index.09b6c50e.js.map"}