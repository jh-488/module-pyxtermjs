<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Python Terminal-Server</title>

  <meta name="description" content="This is a terminal-server based on <a href='https://github.com/cs01/pyxtermjs' target='_blank'>pyxtermjs</a>. A server should be started locally and shared in station mode. For more information and configuration options, see <br><a href='https://github.com/Cross-Lab-Project/edrys_module-pyxtermjs' target='_blank'>Cross-Lab-Project/edrys_module-pyxtermjs</a>">

  <style>html {
  font-family: arial;
}

</style>
  <link rel="stylesheet" href="https://unpkg.com/xterm@4.11.0/css/xterm.css">

  <meta name="show-in" content="station">

  <script src="/index.97a8c616.js"></script><script defer="" src="https://edrys-labs.github.io/module/vendor/alpine.min.js"></script>
  <link rel="stylesheet" href="https://edrys-labs.github.io/module/vendor/water.min.css">
  <link rel="stylesheet" href="https://edrys-labs.github.io/module/vendor/open-iconic/css/open-iconic.min.css">
  <script src="https://edrys-labs.github.io/module/edrys.js"></script>
  <script src="https://unpkg.com/vue@3"></script>
</head>

<body style="max-width: 100%; margin-bottom: 0; padding-left: 0">
  <div id="app">
    <span style="margin-left: 2rem; font-size: small">
      status:
      <span v-if="status === false" style="background-color: #ff8383">disconnected</span>
      <span v-if="status === null">connecting ...</span>
      <span v-if="status === true" style="background-color: #90ee90">connected</span>
    </span>

    <span style="float: right; align-items: center; font-size: small; display: flex" v-if="isStation">
      <label>
        student: <input type="checkbox" v-model="enable.student">
      </label>
      <label>
        teacher: <input type="checkbox" v-model="enable.teacher">
      </label>
      <input type="input" style="display: inline-flex" v-model="server">
      <button style="margin-right: 0; display: inline-flex" @click="reload()">
        reload
      </button>
    </span>

    <textarea style="height: 4.25rem" v-model="script" v-if="isStation">
        {{script}}
      </textarea>
  </div>

  <div style="width: calc(100% + 10px)" id="terminal"></div>

  <!-- xterm -->
  <script src="/index.2317e633.js"></script>
  <script src="/index.28499bfa.js"></script>
  <script src="/index.2803947f.js"></script>
  <script src="/index.e13cebba.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.min.js"></script>

  <!-- trzsz -->
  <script src="/index.74598e8c.js" defer=""></script>

  <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"5KAaQ":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "fa7cdb307f3f2c91";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"cuImQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _module = require("module");
var _moduleDefault = parcelHelpers.interopDefault(_module);
var _trzsz = require("trzsz");
var toUtf8 = function(text) {
    var surrogate = encodeURIComponent(text);
    var result = "";
    for(var i = 0; i < surrogate.length;){
        var character = surrogate[i];
        i += 1;
        if (character == "%") {
            var hex = surrogate.substring(i, i += 2);
            if (hex) result += String.fromCharCode(parseInt(hex, 16));
        } else result += character;
    }
    return result;
};
const { createApp } = Vue;
var terminal = null;
var fit = null;
var socket = null;
var lastData = null;
const terminalElement = document.getElementById("terminal");
let userInput = ""; // Store user input
let isAllowedToDownload = false; // Check if user is allowed to download file
const DEFAULT_SERVER = "http://localhost:5000/pty";
const DEFAULT_SCRIPT = "echo $CODE | base64 --decode";
// trzsz filter 
const trzsz = new (0, _trzsz.TrzszFilter)({
    writeToTerminal: (data)=>terminal.write(typeof data === "string" ? data : new Uint8Array(data)),
    sendToServer: (data)=>{
        if (socket) {
            if (data instanceof Uint8Array) socket.emit("pty-input", {
                input: base64js.fromByteArray(data)
            });
            else socket.emit("pty-input", {
                input: data
            });
        }
    },
    terminalColumns: terminal && terminal.cols
});
function fitToScreen(dimensions) {
    if (fit && terminal) {
        fit.fit();
        let dims = {
            cols: terminal.cols,
            rows: terminal.rows
        };
        if (dimensions?.cols && dimensions?.rows) dims = dimensions;
        // console.log("sending new dimensions to server's pty", dims);
        if (socket) socket.emit("resize", dims);
        else try {
            Edrys.sendMessage("resize", JSON.stringify(dims));
        } catch (e) {}
    }
}
function debounce(func, wait_ms) {
    let timeout;
    return function(...args) {
        const context = this;
        clearTimeout(timeout);
        timeout = setTimeout(()=>func.apply(context, args), wait_ms);
    };
}
function throttle(cb, delay = 500) {
    let storedChange = "";
    let timerID = null;
    function checkStoredArgs() {
        if (storedChange.length > 0) {
            cb(storedChange);
            storedChange = "";
        }
        timerID = null;
    }
    return (change)=>{
        if (timerID) window.clearTimeout(timerID);
        if (change !== null) storedChange += change;
        timerID = window.setTimeout(checkStoredArgs, delay);
    };
}
const app = createApp({
    data () {
        return {
            status: null,
            isStation: false,
            connected: false,
            enable: {
                student: false,
                teacher: false
            },
            server: DEFAULT_SERVER,
            script: DEFAULT_SCRIPT
        };
    },
    methods: {
        reload () {
            if (socket) socket.close();
            this.connectStation();
        },
        execute (code) {
            // add two time ctrl+c to stop a possible execution
            let program = "\x03\x03\n" + this.script;
            if (!program.endsWith("\n")) program += "\n";
            if (Edrys.module) Edrys.sendMessage("input_" + Edrys.role, program.replace("$CODE", btoa(toUtf8(code))));
        },
        store (file) {
            let command = "";
            for(const name in file){
                let content = file[name];
                if (!content.endsWith("\n")) content += "\n";
                command += `echo ${btoa(toUtf8(content))} | base64 --decode > ${toUtf8(name)}\n`;
            }
            //command += "clear\n"
            if (Edrys.module) Edrys.sendMessage("input_" + Edrys.role, command);
        },
        initTerminal () {
            terminal = new Terminal({
                cursorBlink: true,
                macOptionIsMeta: true,
                scrollback: true
            });
            // https://github.com/xtermjs/xterm.js/issues/2941
            terminal.attachCustomKeyEventHandler(customKeyEventHandler);
            fit = new FitAddon.FitAddon();
            terminal.loadAddon(fit);
            terminal.loadAddon(new WebLinksAddon.WebLinksAddon());
            terminal.loadAddon(new SearchAddon.SearchAddon());
            terminal.open(terminalElement);
            fit.fit();
            terminal.resize(12, 50);
            // console.log(`size: ${terminal.cols} columns, ${terminal.rows} rows`);
            fit.fit();
            terminal.writeln("Welcome to pyxterm.js!");
            terminal.writeln("https://github.com/cs01/pyxterm.js");
            terminal.writeln("");
            terminal.writeln("You can copy with ctrl+shift+x");
            terminal.writeln("You can paste with ctrl+shift+v");
            terminal.writeln("");
            const tx = throttle((data)=>{
                //console.log('send input to station:', data)
                Edrys.sendMessage("input_" + Edrys.role, data);
            }, 100);
            // Hidden file input for file picker
            const fileInput = document.createElement("input");
            fileInput.type = "file";
            fileInput.style.display = "none";
            document.body.appendChild(fileInput);
            // Handle file selection and upload
            fileInput.addEventListener("change", async (event)=>{
                if (event.target.files.length > 0) {
                    const filesArray = await Promise.all(Array.from(event.target.files).map((file)=>{
                        return new Promise((resolve, reject)=>{
                            const reader = new FileReader();
                            reader.onload = ()=>{
                                resolve({
                                    name: file.name,
                                    type: file.type,
                                    content: reader.result.split(",")[1] // Get base64 string after "data:<type>;base64,"
                                });
                            };
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                    }));
                    Edrys.sendMessage("upload-files", JSON.stringify(filesArray));
                }
            });
            terminal.onData((data)=>{
                //console.log("key pressed in browser:", data);
                // Handle special user entries (upload, download)
                if (data === "\r") {
                    if (userInput.trim() === "upload" && (Edrys.role === "station" || Edrys.role === "teacher")) {
                        fileInput.click();
                        userInput = "";
                        return;
                    } else if (userInput.startsWith("download")) {
                        const filename = userInput.split(" ")[1];
                        if (!filename) {
                            Edrys.sendMessage("pty-output", "\r\nPlease provide a filename!!\r\n");
                            userInput = "";
                            return;
                        }
                        isAllowedToDownload = true;
                        // Request file from server
                        Edrys.sendMessage("fetch-file", filename);
                        userInput = "";
                        return;
                    }
                    userInput = "";
                } else if (data === "\x7f" || data === "\b") userInput = userInput.slice(0, -1);
                else if (!data.match(/[\x00-\x1F]/)) userInput += data;
                if (socket) /*socket.emit('pty-input', {
                input: data,
              })*/ trzsz.processTerminalInput(data);
                else if (Edrys.module) // send inputData from subRoles
                tx(data);
            });
            terminal.onBinary((data)=>{
                //console.log("binary data received in browser:", data);
                trzsz.processBinaryInput(data);
            });
            // Handle drag and drop file upload
            terminalElement.addEventListener("dragover", (event)=>event.preventDefault());
            terminalElement.addEventListener("drop", (event)=>{
                event.preventDefault();
                trzsz.uploadFiles(event.dataTransfer.items).then(()=>{
                    console.log("upload success");
                }).catch((err)=>console.log(err));
            });
            function customKeyEventHandler(e) {
                if (e.type !== "keydown") return true;
                if (e.ctrlKey && e.shiftKey) {
                    const key = e.key.toLowerCase();
                    if (key === "v") {
                        // ctrl+shift+v: paste whatever is in the clipboard
                        navigator.clipboard.readText().then((toPaste)=>{
                            if (socket) socket.emit("pty-input", {
                                input: toPaste
                            });
                            else if (Edrys.module) // send inputData from subRoles
                            tx(toPaste);
                        });
                        return false;
                    } else if (key === "c" || key === "x") {
                        // ctrl+shift+x: copy whatever is highlighted to clipboard
                        // 'x' is used as an alternate to 'c' because ctrl+c is taken
                        // by the terminal (SIGINT) and ctrl+shift+c is taken by the browser
                        // (open devtools).
                        // I'm not aware of ctrl+shift+x being used by anything in the terminal
                        // or browser
                        const toCopy = terminal.getSelection();
                        navigator.clipboard.writeText(toCopy);
                        terminal.focus();
                        return false;
                    }
                }
                return true;
            }
            const wait_ms = 50;
            window.onresize = debounce(fitToScreen, wait_ms);
        },
        // Upload file 
        uploadFilesToTerminal (filesData) {
            const data = JSON.parse(filesData);
            const dataTransfer = new DataTransfer();
            data.forEach((fileData)=>{
                // Decode base64 string back to binary
                const binaryContent = atob(fileData.content);
                const binaryArray = new Uint8Array(binaryContent.length);
                for(let i = 0; i < binaryContent.length; i++)binaryArray[i] = binaryContent.charCodeAt(i);
                // Create a File object from the binary content
                const file = new File([
                    binaryArray
                ], fileData.name, {
                    type: fileData.type
                });
                dataTransfer.items.add(file);
            });
            const filesList = dataTransfer.files;
            trzsz.uploadFiles(filesList).then(()=>{
                console.log("Upload successful");
            }).catch((err)=>console.error("Upload failed:", err));
        },
        // Download file 
        downloadFile (fileData) {
            const parsedFileData = JSON.parse(fileData);
            const fileName = parsedFileData.name;
            const base64String = parsedFileData.content;
            if (fileName) {
                const fileBlob = new Blob([
                    Uint8Array.from(atob(base64String), (c)=>c.charCodeAt(0))
                ]);
                const url = URL.createObjectURL(fileBlob);
                const link = document.createElement("a");
                link.href = url;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                // Clean up URL object to free up memory
                URL.revokeObjectURL(url);
                terminal.write(`\r\n${fileName} downloaded\r\n`);
                trzsz.sendToServer("\x03");
            } else terminal.write("\r\nNo file found to download.\r\n");
        },
        connectUser () {
            const self = this;
            Edrys.onMessage(({ from, subject, body })=>{
                //console.log('User got new message: ', subject, body)
                switch(subject){
                    case "pty-output":
                        trzsz.processServerOutput(body);
                        break;
                    case "connect":
                        if (body === "true") self.status = true;
                        else if (body === "false") self.status = false;
                        else self.status = null;
                        fitToScreen();
                        break;
                    case "download-file":
                        // Only download file for current user
                        if (isAllowedToDownload) {
                            self.downloadFile(body);
                            isAllowedToDownload = false;
                        }
                        break;
                    case "upload-files":
                        self.uploadFilesToTerminal(body);
                        break;
                }
            });
        },
        connectStation () {
            socket = io.connect(this.server, {
                reconnectionAttempts: Infinity
            });
            socket.on("connect_error", (error)=>{
                console.log("Connection error:", error.message);
            });
            const self = this;
            socket.on("pty-output", function(data) {
                // console.log("new output received from server:", data.output);
                trzsz.processServerOutput(data.output);
                //terminal.write(data.output)
                if (Edrys.module) Edrys.sendMessage("pty-output", data.output);
                lastData = data.output;
            });
            socket.on("fetch-file-response", (data)=>{
                const fileData = JSON.stringify({
                    name: data.name,
                    content: data.content
                });
                if (Edrys.module) // Send file data to user
                Edrys.sendMessage("download-file", fileData);
            });
            socket.on("connect", ()=>{
                fitToScreen();
                self.status = true;
                if (Edrys.module) Edrys.sendMessage("connect", "true");
                // simply an starting enter to receive outputs
                socket.emit("pty-input", {
                    input: "\n"
                });
            });
            socket.on("disconnect", ()=>{
                self.status = false;
                if (Edrys.module) Edrys.sendMessage("connect", "false");
            });
            if (Edrys.module) {
                Edrys.onMessage(({ from, subject, body })=>{
                    // console.log('Got new message: ', from, subject, JSON.stringify(body))
                    switch(subject){
                        case "input_teacher":
                            if (self.enable.teacher) socket.emit("pty-input", {
                                input: body
                            });
                            break;
                        case "input_student":
                            if (self.enable.student) socket.emit("pty-input", {
                                input: body
                            });
                            break;
                        case "input_station":
                            socket.emit("pty-input", {
                                input: body
                            });
                            break;
                        case "join":
                            Edrys.sendMessage("connect", JSON.stringify(self.status));
                            Edrys.sendMessage("pty-output", lastData);
                            break;
                        case "resize":
                            {
                                let data = JSON.parse(body);
                                fitToScreen(data);
                                break;
                            }
                        case "download-file":
                            // Only download file for current user
                            if (isAllowedToDownload) {
                                self.downloadFile(body);
                                console.log("File downloaded");
                                isAllowedToDownload = false;
                            }
                            break;
                        case "upload-files":
                            self.uploadFilesToTerminal(body);
                            break;
                        case "fetch-file":
                            socket.emit("fetch-file", body);
                            break;
                    }
                });
                Edrys.onMessage(({ from, subject, body, module })=>{
                    // console.log("Got new message: ", from, subject, body, module, Edrys.module.stationConfig?.execute)
                    if (subject === (Edrys.module.stationConfig?.execute || "execute")) {
                        try {
                            let data = JSON.parse(body);
                            if (data.file) {
                                self.store(data.file);
                                self.execute("");
                                return;
                            }
                        } catch (e) {
                            console.warn("Error, could not execute command:", e.message);
                        }
                        self.execute(body);
                    }
                }, promiscuous = true);
            }
        }
    }
}).mount("#app");
app.initTerminal();
Edrys.onReady(()=>{
    console.log("Module is loaded!");
    //Edrys.onUpdate((e) =>
    //  console.warn('Something has changed in the class', e)
    //)
    if (Edrys.role === "station") {
        app.isStation = true;
        app.server = Edrys.module.stationConfig?.server || DEFAULT_SERVER;
        app.script = Edrys.module.stationConfig?.script || DEFAULT_SCRIPT;
        app.enable.student = Edrys.module.stationConfig?.enable?.student || false;
        app.enable.teacher = Edrys.module.stationConfig?.enable?.teacher || false;
        app.connectStation();
        Edrys.sendMessage("join", null);
    } else {
        app.connectUser();
        Edrys.sendMessage("join", null);
    }
});
setTimeout(function() {
    if (!Edrys.module) {
        console.warn("connect");
        app.connectStation();
    // app.isStation = true
    }
}, 5000);

},{"module":"jhUEF","trzsz":"jYUTq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jYUTq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TrzszAddon", ()=>pr);
parcelHelpers.export(exports, "TrzszFilter", ()=>wr);
var process = require("84ee08d945baaea5");
var Buffer = require("e72d965fc01fbcad").Buffer;
function t(t, e, i, r) {
    return new (i || (i = Promise))(function(n, s) {
        function a(t) {
            try {
                l(r.next(t));
            } catch (t) {
                s(t);
            }
        }
        function o(t) {
            try {
                l(r.throw(t));
            } catch (t) {
                s(t);
            }
        }
        function l(t) {
            var e;
            t.done ? n(t.value) : (e = t.value, e instanceof i ? e : new i(function(t) {
                t(e);
            })).then(a, o);
        }
        l((r = r.apply(t, e || [])).next());
    });
}
function e(t) {
    var e = "function" == typeof Symbol && Symbol.iterator, i = e && t[e], r = 0;
    if (i) return i.call(t);
    if (t && "number" == typeof t.length) return {
        next: function() {
            return t && r >= t.length && (t = void 0), {
                value: t && t[r++],
                done: !t
            };
        }
    };
    throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function i(t) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var i, r = t[Symbol.asyncIterator];
    return r ? r.call(t) : (t = e(t), i = {}, n("next"), n("throw"), n("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    function n(e) {
        i[e] = t[e] && function(i) {
            return new Promise(function(r, n) {
                (function(t, e, i, r) {
                    Promise.resolve(r).then(function(e) {
                        t({
                            value: e,
                            done: i
                        });
                    }, e);
                })(r, n, (i = t[e](i)).done, i.value);
            });
        };
    }
}
"function" == typeof SuppressedError && SuppressedError;
function r(t) {
    let e = t.length;
    for(; --e >= 0;)t[e] = 0;
}
const n = 256, s = 286, a = 30, o = 15, l = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0
]), h = new Uint8Array([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13
]), d = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    2,
    3,
    7
]), u = new Uint8Array([
    16,
    17,
    18,
    0,
    8,
    7,
    9,
    6,
    10,
    5,
    11,
    4,
    12,
    3,
    13,
    2,
    14,
    1,
    15
]), f = new Array(576);
r(f);
const c = new Array(60);
r(c);
const _ = new Array(512);
r(_);
const w = new Array(256);
r(w);
const p = new Array(29);
r(p);
const m = new Array(a);
function g(t, e, i, r, n) {
    this.static_tree = t, this.extra_bits = e, this.extra_base = i, this.elems = r, this.max_length = n, this.has_stree = t && t.length;
}
let y, b, v;
function k(t, e) {
    this.dyn_tree = t, this.max_code = 0, this.stat_desc = e;
}
r(m);
const x = (t)=>t < 256 ? _[t] : _[256 + (t >>> 7)], z = (t, e)=>{
    t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255;
}, A = (t, e, i)=>{
    t.bi_valid > 16 - i ? (t.bi_buf |= e << t.bi_valid & 65535, z(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += i - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += i);
}, S = (t, e, i)=>{
    A(t, i[2 * e], i[2 * e + 1]);
}, T = (t, e)=>{
    let i = 0;
    do i |= 1 & t, t >>>= 1, i <<= 1;
    while (--e > 0);
    return i >>> 1;
}, F = (t, e, i)=>{
    const r = new Array(16);
    let n, s, a = 0;
    for(n = 1; n <= o; n++)a = a + i[n - 1] << 1, r[n] = a;
    for(s = 0; s <= e; s++){
        let e = t[2 * s + 1];
        0 !== e && (t[2 * s] = T(r[e]++, e));
    }
}, I = (t)=>{
    let e;
    for(e = 0; e < s; e++)t.dyn_ltree[2 * e] = 0;
    for(e = 0; e < a; e++)t.dyn_dtree[2 * e] = 0;
    for(e = 0; e < 19; e++)t.bl_tree[2 * e] = 0;
    t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0;
}, E = (t)=>{
    t.bi_valid > 8 ? z(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0;
}, C = (t, e, i, r)=>{
    const n = 2 * e, s = 2 * i;
    return t[n] < t[s] || t[n] === t[s] && r[e] <= r[i];
}, B = (t, e, i)=>{
    const r = t.heap[i];
    let n = i << 1;
    for(; n <= t.heap_len && (n < t.heap_len && C(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !C(e, r, t.heap[n], t.depth));)t.heap[i] = t.heap[n], i = n, n <<= 1;
    t.heap[i] = r;
}, D = (t, e, i)=>{
    let r, s, a, o, d = 0;
    if (0 !== t.sym_next) do r = 255 & t.pending_buf[t.sym_buf + d++], r += (255 & t.pending_buf[t.sym_buf + d++]) << 8, s = t.pending_buf[t.sym_buf + d++], 0 === r ? S(t, s, e) : (a = w[s], S(t, a + n + 1, e), o = l[a], 0 !== o && (s -= p[a], A(t, s, o)), r--, a = x(r), S(t, a, i), o = h[a], 0 !== o && (r -= m[a], A(t, r, o)));
    while (d < t.sym_next);
    S(t, 256, e);
}, R = (t, e)=>{
    const i = e.dyn_tree, r = e.stat_desc.static_tree, n = e.stat_desc.has_stree, s = e.stat_desc.elems;
    let a, l, h, d = -1;
    for(t.heap_len = 0, t.heap_max = 573, a = 0; a < s; a++)0 !== i[2 * a] ? (t.heap[++t.heap_len] = d = a, t.depth[a] = 0) : i[2 * a + 1] = 0;
    for(; t.heap_len < 2;)h = t.heap[++t.heap_len] = d < 2 ? ++d : 0, i[2 * h] = 1, t.depth[h] = 0, t.opt_len--, n && (t.static_len -= r[2 * h + 1]);
    for(e.max_code = d, a = t.heap_len >> 1; a >= 1; a--)B(t, i, a);
    h = s;
    do a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], B(t, i, 1), l = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = l, i[2 * h] = i[2 * a] + i[2 * l], t.depth[h] = (t.depth[a] >= t.depth[l] ? t.depth[a] : t.depth[l]) + 1, i[2 * a + 1] = i[2 * l + 1] = h, t.heap[1] = h++, B(t, i, 1);
    while (t.heap_len >= 2);
    t.heap[--t.heap_max] = t.heap[1], ((t, e)=>{
        const i = e.dyn_tree, r = e.max_code, n = e.stat_desc.static_tree, s = e.stat_desc.has_stree, a = e.stat_desc.extra_bits, l = e.stat_desc.extra_base, h = e.stat_desc.max_length;
        let d, u, f, c, _, w, p = 0;
        for(c = 0; c <= o; c++)t.bl_count[c] = 0;
        for(i[2 * t.heap[t.heap_max] + 1] = 0, d = t.heap_max + 1; d < 573; d++)u = t.heap[d], c = i[2 * i[2 * u + 1] + 1] + 1, c > h && (c = h, p++), i[2 * u + 1] = c, u > r || (t.bl_count[c]++, _ = 0, u >= l && (_ = a[u - l]), w = i[2 * u], t.opt_len += w * (c + _), s && (t.static_len += w * (n[2 * u + 1] + _)));
        if (0 !== p) {
            do {
                for(c = h - 1; 0 === t.bl_count[c];)c--;
                t.bl_count[c]--, t.bl_count[c + 1] += 2, t.bl_count[h]--, p -= 2;
            }while (p > 0);
            for(c = h; 0 !== c; c--)for(u = t.bl_count[c]; 0 !== u;)f = t.heap[--d], f > r || (i[2 * f + 1] !== c && (t.opt_len += (c - i[2 * f + 1]) * i[2 * f], i[2 * f + 1] = c), u--);
        }
    })(t, e), F(i, d, t.bl_count);
}, U = (t, e, i)=>{
    let r, n, s = -1, a = e[1], o = 0, l = 7, h = 4;
    for(0 === a && (l = 138, h = 3), e[2 * (i + 1) + 1] = 65535, r = 0; r <= i; r++)n = a, a = e[2 * (r + 1) + 1], ++o < l && n === a || (o < h ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== s && t.bl_tree[2 * n]++, t.bl_tree[32]++) : o <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, o = 0, s = n, 0 === a ? (l = 138, h = 3) : n === a ? (l = 6, h = 3) : (l = 7, h = 4));
}, L = (t, e, i)=>{
    let r, n, s = -1, a = e[1], o = 0, l = 7, h = 4;
    for(0 === a && (l = 138, h = 3), r = 0; r <= i; r++)if (n = a, a = e[2 * (r + 1) + 1], !(++o < l && n === a)) {
        if (o < h) do S(t, n, t.bl_tree);
        while (0 != --o);
        else 0 !== n ? (n !== s && (S(t, n, t.bl_tree), o--), S(t, 16, t.bl_tree), A(t, o - 3, 2)) : o <= 10 ? (S(t, 17, t.bl_tree), A(t, o - 3, 3)) : (S(t, 18, t.bl_tree), A(t, o - 11, 7));
        o = 0, s = n, 0 === a ? (l = 138, h = 3) : n === a ? (l = 6, h = 3) : (l = 7, h = 4);
    }
};
let N = !1;
const P = (t, e, i, r)=>{
    A(t, 0 + (r ? 1 : 0), 3), E(t), z(t, i), z(t, ~i), i && t.pending_buf.set(t.window.subarray(e, e + i), t.pending), t.pending += i;
};
var O = (t)=>{
    N || ((()=>{
        let t, e, i, r, n;
        const u = new Array(16);
        for(i = 0, r = 0; r < 28; r++)for(p[r] = i, t = 0; t < 1 << l[r]; t++)w[i++] = r;
        for(w[i - 1] = r, n = 0, r = 0; r < 16; r++)for(m[r] = n, t = 0; t < 1 << h[r]; t++)_[n++] = r;
        for(n >>= 7; r < a; r++)for(m[r] = n << 7, t = 0; t < 1 << h[r] - 7; t++)_[256 + n++] = r;
        for(e = 0; e <= o; e++)u[e] = 0;
        for(t = 0; t <= 143;)f[2 * t + 1] = 8, t++, u[8]++;
        for(; t <= 255;)f[2 * t + 1] = 9, t++, u[9]++;
        for(; t <= 279;)f[2 * t + 1] = 7, t++, u[7]++;
        for(; t <= 287;)f[2 * t + 1] = 8, t++, u[8]++;
        for(F(f, 287, u), t = 0; t < a; t++)c[2 * t + 1] = 5, c[2 * t] = T(t, 5);
        y = new g(f, l, 257, s, o), b = new g(c, h, 0, a, o), v = new g(new Array(0), d, 0, 19, 7);
    })(), N = !0), t.l_desc = new k(t.dyn_ltree, y), t.d_desc = new k(t.dyn_dtree, b), t.bl_desc = new k(t.bl_tree, v), t.bi_buf = 0, t.bi_valid = 0, I(t);
}, Z = (t, e, i, r)=>{
    let s, a, o = 0;
    t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = ((t)=>{
        let e, i = 4093624447;
        for(e = 0; e <= 31; e++, i >>>= 1)if (1 & i && 0 !== t.dyn_ltree[2 * e]) return 0;
        if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
        for(e = 32; e < n; e++)if (0 !== t.dyn_ltree[2 * e]) return 1;
        return 0;
    })(t)), R(t, t.l_desc), R(t, t.d_desc), o = ((t)=>{
        let e;
        for(U(t, t.dyn_ltree, t.l_desc.max_code), U(t, t.dyn_dtree, t.d_desc.max_code), R(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * u[e] + 1]; e--);
        return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e;
    })(t), s = t.opt_len + 3 + 7 >>> 3, a = t.static_len + 3 + 7 >>> 3, a <= s && (s = a)) : s = a = i + 5, i + 4 <= s && -1 !== e ? P(t, e, i, r) : 4 === t.strategy || a === s ? (A(t, 2 + (r ? 1 : 0), 3), D(t, f, c)) : (A(t, 4 + (r ? 1 : 0), 3), ((t, e, i, r)=>{
        let n;
        for(A(t, e - 257, 5), A(t, i - 1, 5), A(t, r - 4, 4), n = 0; n < r; n++)A(t, t.bl_tree[2 * u[n] + 1], 3);
        L(t, t.dyn_ltree, e - 1), L(t, t.dyn_dtree, i - 1);
    })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, o + 1), D(t, t.dyn_ltree, t.dyn_dtree)), I(t), r && E(t);
}, M = {
    _tr_init: O,
    _tr_stored_block: P,
    _tr_flush_block: Z,
    _tr_tally: (t, e, i)=>(t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = i, 0 === e ? t.dyn_ltree[2 * i]++ : (t.matches++, e--, t.dyn_ltree[2 * (w[i] + n + 1)]++, t.dyn_dtree[2 * x(e)]++), t.sym_next === t.sym_end),
    _tr_align: (t)=>{
        A(t, 2, 3), S(t, 256, f), ((t)=>{
            16 === t.bi_valid ? (z(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8);
        })(t);
    }
};
var $ = (t, e, i, r)=>{
    let n = 65535 & t | 0, s = t >>> 16 & 65535 | 0, a = 0;
    for(; 0 !== i;){
        a = i > 2e3 ? 2e3 : i, i -= a;
        do n = n + e[r++] | 0, s = s + n | 0;
        while (--a);
        n %= 65521, s %= 65521;
    }
    return n | s << 16 | 0;
};
const j = new Uint32Array((()=>{
    let t, e = [];
    for(var i = 0; i < 256; i++){
        t = i;
        for(var r = 0; r < 8; r++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
        e[i] = t;
    }
    return e;
})());
var H = (t, e, i, r)=>{
    const n = j, s = r + i;
    t ^= -1;
    for(let i = r; i < s; i++)t = t >>> 8 ^ n[255 & (t ^ e[i])];
    return -1 ^ t;
}, W = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}, q = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    Z_BINARY: 0,
    Z_TEXT: 1,
    Z_UNKNOWN: 2,
    Z_DEFLATED: 8
};
const { _tr_init: K, _tr_stored_block: J, _tr_flush_block: G, _tr_tally: X, _tr_align: Y } = M, { Z_NO_FLUSH: Q, Z_PARTIAL_FLUSH: V, Z_FULL_FLUSH: tt, Z_FINISH: et, Z_BLOCK: it, Z_OK: rt, Z_STREAM_END: nt, Z_STREAM_ERROR: st, Z_DATA_ERROR: at, Z_BUF_ERROR: ot, Z_DEFAULT_COMPRESSION: lt, Z_FILTERED: ht, Z_HUFFMAN_ONLY: dt, Z_RLE: ut, Z_FIXED: ft, Z_DEFAULT_STRATEGY: ct, Z_UNKNOWN: _t, Z_DEFLATED: wt } = q, pt = 258, mt = 262, gt = 42, yt = 113, bt = 666, vt = (t, e)=>(t.msg = W[e], e), kt = (t)=>2 * t - (t > 4 ? 9 : 0), xt = (t)=>{
    let e = t.length;
    for(; --e >= 0;)t[e] = 0;
}, zt = (t)=>{
    let e, i, r, n = t.w_size;
    e = t.hash_size, r = e;
    do i = t.head[--r], t.head[r] = i >= n ? i - n : 0;
    while (--e);
    e = n, r = e;
    do i = t.prev[--r], t.prev[r] = i >= n ? i - n : 0;
    while (--e);
};
let At = (t, e, i)=>(e << t.hash_shift ^ i) & t.hash_mask;
const St = (t)=>{
    const e = t.state;
    let i = e.pending;
    i > t.avail_out && (i = t.avail_out), 0 !== i && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + i), t.next_out), t.next_out += i, e.pending_out += i, t.total_out += i, t.avail_out -= i, e.pending -= i, 0 === e.pending && (e.pending_out = 0));
}, Tt = (t, e)=>{
    G(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, St(t.strm);
}, Ft = (t, e)=>{
    t.pending_buf[t.pending++] = e;
}, It = (t, e)=>{
    t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e;
}, Et = (t, e, i, r)=>{
    let n = t.avail_in;
    return n > r && (n = r), 0 === n ? 0 : (t.avail_in -= n, e.set(t.input.subarray(t.next_in, t.next_in + n), i), 1 === t.state.wrap ? t.adler = $(t.adler, e, n, i) : 2 === t.state.wrap && (t.adler = H(t.adler, e, n, i)), t.next_in += n, t.total_in += n, n);
}, Ct = (t, e)=>{
    let i, r, n = t.max_chain_length, s = t.strstart, a = t.prev_length, o = t.nice_match;
    const l = t.strstart > t.w_size - mt ? t.strstart - (t.w_size - mt) : 0, h = t.window, d = t.w_mask, u = t.prev, f = t.strstart + pt;
    let c = h[s + a - 1], _ = h[s + a];
    t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead);
    do if (i = e, h[i + a] === _ && h[i + a - 1] === c && h[i] === h[s] && h[++i] === h[s + 1]) {
        s += 2, i++;
        do ;
        while (h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && h[++s] === h[++i] && s < f);
        if (r = pt - (f - s), s = f - pt, r > a) {
            if (t.match_start = e, a = r, r >= o) break;
            c = h[s + a - 1], _ = h[s + a];
        }
    }
    while ((e = u[e & d]) > l && 0 != --n);
    return a <= t.lookahead ? a : t.lookahead;
}, Bt = (t)=>{
    const e = t.w_size;
    let i, r, n;
    do {
        if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - mt) && (t.window.set(t.window.subarray(e, e + e - r), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), zt(t), r += e), 0 === t.strm.avail_in) break;
        if (i = Et(t.strm, t.window, t.strstart + t.lookahead, r), t.lookahead += i, t.lookahead + t.insert >= 3) for(n = t.strstart - t.insert, t.ins_h = t.window[n], t.ins_h = At(t, t.ins_h, t.window[n + 1]); t.insert && (t.ins_h = At(t, t.ins_h, t.window[n + 3 - 1]), t.prev[n & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = n, n++, t.insert--, !(t.lookahead + t.insert < 3)););
    }while (t.lookahead < mt && 0 !== t.strm.avail_in);
}, Dt = (t, e)=>{
    let i, r, n, s = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5, a = 0, o = t.strm.avail_in;
    do {
        if (i = 65535, n = t.bi_valid + 42 >> 3, t.strm.avail_out < n) break;
        if (n = t.strm.avail_out - n, r = t.strstart - t.block_start, i > r + t.strm.avail_in && (i = r + t.strm.avail_in), i > n && (i = n), i < s && (0 === i && e !== et || e === Q || i !== r + t.strm.avail_in)) break;
        a = e === et && i === r + t.strm.avail_in ? 1 : 0, J(t, 0, 0, a), t.pending_buf[t.pending - 4] = i, t.pending_buf[t.pending - 3] = i >> 8, t.pending_buf[t.pending - 2] = ~i, t.pending_buf[t.pending - 1] = ~i >> 8, St(t.strm), r && (r > i && (r = i), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + r), t.strm.next_out), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r, t.block_start += r, i -= r), i && (Et(t.strm, t.strm.output, t.strm.next_out, i), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i);
    }while (0 === a);
    return o -= t.strm.avail_in, o && (o >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= o && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - o, t.strm.next_in), t.strstart), t.strstart += o, t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), a ? 4 : e !== Q && e !== et && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (n = t.window_size - t.strstart, t.strm.avail_in > n && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, n += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), n > t.strm.avail_in && (n = t.strm.avail_in), n && (Et(t.strm, t.window, t.strstart, n), t.strstart += n, t.insert += n > t.w_size - t.insert ? t.w_size - t.insert : n), t.high_water < t.strstart && (t.high_water = t.strstart), n = t.bi_valid + 42 >> 3, n = t.pending_buf_size - n > 65535 ? 65535 : t.pending_buf_size - n, s = n > t.w_size ? t.w_size : n, r = t.strstart - t.block_start, (r >= s || (r || e === et) && e !== Q && 0 === t.strm.avail_in && r <= n) && (i = r > n ? n : r, a = e === et && 0 === t.strm.avail_in && i === r ? 1 : 0, J(t, t.block_start, i, a), t.block_start += i, St(t.strm)), a ? 3 : 1);
}, Rt = (t, e)=>{
    let i, r;
    for(;;){
        if (t.lookahead < mt) {
            if (Bt(t), t.lookahead < mt && e === Q) return 1;
            if (0 === t.lookahead) break;
        }
        if (i = 0, t.lookahead >= 3 && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== i && t.strstart - i <= t.w_size - mt && (t.match_length = Ct(t, i)), t.match_length >= 3) {
            if (r = X(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) {
                t.match_length--;
                do t.strstart++, t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart;
                while (0 != --t.match_length);
                t.strstart++;
            } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = At(t, t.ins_h, t.window[t.strstart + 1]);
        } else r = X(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
        if (r && (Tt(t, !1), 0 === t.strm.avail_out)) return 1;
    }
    return t.insert = t.strstart < 2 ? t.strstart : 2, e === et ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Tt(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
}, Ut = (t, e)=>{
    let i, r, n;
    for(;;){
        if (t.lookahead < mt) {
            if (Bt(t), t.lookahead < mt && e === Q) return 1;
            if (0 === t.lookahead) break;
        }
        if (i = 0, t.lookahead >= 3 && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== i && t.prev_length < t.max_lazy_match && t.strstart - i <= t.w_size - mt && (t.match_length = Ct(t, i), t.match_length <= 5 && (t.strategy === ht || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) {
            n = t.strstart + t.lookahead - 3, r = X(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
            do ++t.strstart <= n && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), i = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart);
            while (0 != --t.prev_length);
            if (t.match_available = 0, t.match_length = 2, t.strstart++, r && (Tt(t, !1), 0 === t.strm.avail_out)) return 1;
        } else if (t.match_available) {
            if (r = X(t, 0, t.window[t.strstart - 1]), r && Tt(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1;
        } else t.match_available = 1, t.strstart++, t.lookahead--;
    }
    return t.match_available && (r = X(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, e === et ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Tt(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
};
function Lt(t, e, i, r, n) {
    this.good_length = t, this.max_lazy = e, this.nice_length = i, this.max_chain = r, this.func = n;
}
const Nt = [
    new Lt(0, 0, 0, 0, Dt),
    new Lt(4, 4, 8, 4, Rt),
    new Lt(4, 5, 16, 8, Rt),
    new Lt(4, 6, 32, 32, Rt),
    new Lt(4, 4, 16, 16, Ut),
    new Lt(8, 16, 32, 32, Ut),
    new Lt(8, 16, 128, 128, Ut),
    new Lt(8, 32, 128, 256, Ut),
    new Lt(32, 128, 258, 1024, Ut),
    new Lt(32, 258, 258, 4096, Ut)
];
function Pt() {
    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = wt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), xt(this.dyn_ltree), xt(this.dyn_dtree), xt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), xt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), xt(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
}
const Ot = (t)=>{
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || e.status !== gt && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && e.status !== yt && e.status !== bt ? 1 : 0;
}, Zt = (t)=>{
    if (Ot(t)) return vt(t, st);
    t.total_in = t.total_out = 0, t.data_type = _t;
    const e = t.state;
    return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = 2 === e.wrap ? 57 : e.wrap ? gt : yt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = -2, K(e), rt;
}, Mt = (t)=>{
    const e = Zt(t);
    var i;
    return e === rt && ((i = t.state).window_size = 2 * i.w_size, xt(i.head), i.max_lazy_match = Nt[i.level].max_lazy, i.good_match = Nt[i.level].good_length, i.nice_match = Nt[i.level].nice_length, i.max_chain_length = Nt[i.level].max_chain, i.strstart = 0, i.block_start = 0, i.lookahead = 0, i.insert = 0, i.match_length = i.prev_length = 2, i.match_available = 0, i.ins_h = 0), e;
}, $t = (t, e, i, r, n, s)=>{
    if (!t) return st;
    let a = 1;
    if (e === lt && (e = 6), r < 0 ? (a = 0, r = -r) : r > 15 && (a = 2, r -= 16), n < 1 || n > 9 || i !== wt || r < 8 || r > 15 || e < 0 || e > 9 || s < 0 || s > ft || 8 === r && 1 !== a) return vt(t, st);
    8 === r && (r = 9);
    const o = new Pt;
    return t.state = o, o.strm = t, o.status = gt, o.wrap = a, o.gzhead = null, o.w_bits = r, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = n + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3), o.window = new Uint8Array(2 * o.w_size), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << n + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = 3 * (o.lit_bufsize - 1), o.level = e, o.strategy = s, o.method = i, Mt(t);
};
var jt = {
    deflateInit: (t, e)=>$t(t, e, wt, 15, 8, ct),
    deflateInit2: $t,
    deflateReset: Mt,
    deflateResetKeep: Zt,
    deflateSetHeader: (t, e)=>Ot(t) || 2 !== t.state.wrap ? st : (t.state.gzhead = e, rt),
    deflate: (t, e)=>{
        if (Ot(t) || e > it || e < 0) return t ? vt(t, st) : st;
        const i = t.state;
        if (!t.output || 0 !== t.avail_in && !t.input || i.status === bt && e !== et) return vt(t, 0 === t.avail_out ? ot : st);
        const r = i.last_flush;
        if (i.last_flush = e, 0 !== i.pending) {
            if (St(t), 0 === t.avail_out) return i.last_flush = -1, rt;
        } else if (0 === t.avail_in && kt(e) <= kt(r) && e !== et) return vt(t, ot);
        if (i.status === bt && 0 !== t.avail_in) return vt(t, ot);
        if (i.status === gt && 0 === i.wrap && (i.status = yt), i.status === gt) {
            let e = wt + (i.w_bits - 8 << 4) << 8, r = -1;
            if (r = i.strategy >= dt || i.level < 2 ? 0 : i.level < 6 ? 1 : 6 === i.level ? 2 : 3, e |= r << 6, 0 !== i.strstart && (e |= 32), e += 31 - e % 31, It(i, e), 0 !== i.strstart && (It(i, t.adler >>> 16), It(i, 65535 & t.adler)), t.adler = 1, i.status = yt, St(t), 0 !== i.pending) return i.last_flush = -1, rt;
        }
        if (57 === i.status) {
            if (t.adler = 0, Ft(i, 31), Ft(i, 139), Ft(i, 8), i.gzhead) Ft(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), Ft(i, 255 & i.gzhead.time), Ft(i, i.gzhead.time >> 8 & 255), Ft(i, i.gzhead.time >> 16 & 255), Ft(i, i.gzhead.time >> 24 & 255), Ft(i, 9 === i.level ? 2 : i.strategy >= dt || i.level < 2 ? 4 : 0), Ft(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (Ft(i, 255 & i.gzhead.extra.length), Ft(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = H(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69;
            else if (Ft(i, 0), Ft(i, 0), Ft(i, 0), Ft(i, 0), Ft(i, 0), Ft(i, 9 === i.level ? 2 : i.strategy >= dt || i.level < 2 ? 4 : 0), Ft(i, 3), i.status = yt, St(t), 0 !== i.pending) return i.last_flush = -1, rt;
        }
        if (69 === i.status) {
            if (i.gzhead.extra) {
                let e = i.pending, r = (65535 & i.gzhead.extra.length) - i.gzindex;
                for(; i.pending + r > i.pending_buf_size;){
                    let n = i.pending_buf_size - i.pending;
                    if (i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex, i.gzindex + n), i.pending), i.pending = i.pending_buf_size, i.gzhead.hcrc && i.pending > e && (t.adler = H(t.adler, i.pending_buf, i.pending - e, e)), i.gzindex += n, St(t), 0 !== i.pending) return i.last_flush = -1, rt;
                    e = 0, r -= n;
                }
                let n = new Uint8Array(i.gzhead.extra);
                i.pending_buf.set(n.subarray(i.gzindex, i.gzindex + r), i.pending), i.pending += r, i.gzhead.hcrc && i.pending > e && (t.adler = H(t.adler, i.pending_buf, i.pending - e, e)), i.gzindex = 0;
            }
            i.status = 73;
        }
        if (73 === i.status) {
            if (i.gzhead.name) {
                let e, r = i.pending;
                do {
                    if (i.pending === i.pending_buf_size) {
                        if (i.gzhead.hcrc && i.pending > r && (t.adler = H(t.adler, i.pending_buf, i.pending - r, r)), St(t), 0 !== i.pending) return i.last_flush = -1, rt;
                        r = 0;
                    }
                    e = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, Ft(i, e);
                }while (0 !== e);
                i.gzhead.hcrc && i.pending > r && (t.adler = H(t.adler, i.pending_buf, i.pending - r, r)), i.gzindex = 0;
            }
            i.status = 91;
        }
        if (91 === i.status) {
            if (i.gzhead.comment) {
                let e, r = i.pending;
                do {
                    if (i.pending === i.pending_buf_size) {
                        if (i.gzhead.hcrc && i.pending > r && (t.adler = H(t.adler, i.pending_buf, i.pending - r, r)), St(t), 0 !== i.pending) return i.last_flush = -1, rt;
                        r = 0;
                    }
                    e = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, Ft(i, e);
                }while (0 !== e);
                i.gzhead.hcrc && i.pending > r && (t.adler = H(t.adler, i.pending_buf, i.pending - r, r));
            }
            i.status = 103;
        }
        if (103 === i.status) {
            if (i.gzhead.hcrc) {
                if (i.pending + 2 > i.pending_buf_size && (St(t), 0 !== i.pending)) return i.last_flush = -1, rt;
                Ft(i, 255 & t.adler), Ft(i, t.adler >> 8 & 255), t.adler = 0;
            }
            if (i.status = yt, St(t), 0 !== i.pending) return i.last_flush = -1, rt;
        }
        if (0 !== t.avail_in || 0 !== i.lookahead || e !== Q && i.status !== bt) {
            let r = 0 === i.level ? Dt(i, e) : i.strategy === dt ? ((t, e)=>{
                let i;
                for(;;){
                    if (0 === t.lookahead && (Bt(t), 0 === t.lookahead)) {
                        if (e === Q) return 1;
                        break;
                    }
                    if (t.match_length = 0, i = X(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, i && (Tt(t, !1), 0 === t.strm.avail_out)) return 1;
                }
                return t.insert = 0, e === et ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Tt(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
            })(i, e) : i.strategy === ut ? ((t, e)=>{
                let i, r, n, s;
                const a = t.window;
                for(;;){
                    if (t.lookahead <= pt) {
                        if (Bt(t), t.lookahead <= pt && e === Q) return 1;
                        if (0 === t.lookahead) break;
                    }
                    if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (n = t.strstart - 1, r = a[n], r === a[++n] && r === a[++n] && r === a[++n])) {
                        s = t.strstart + pt;
                        do ;
                        while (r === a[++n] && r === a[++n] && r === a[++n] && r === a[++n] && r === a[++n] && r === a[++n] && r === a[++n] && r === a[++n] && n < s);
                        t.match_length = pt - (s - n), t.match_length > t.lookahead && (t.match_length = t.lookahead);
                    }
                    if (t.match_length >= 3 ? (i = X(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (i = X(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), i && (Tt(t, !1), 0 === t.strm.avail_out)) return 1;
                }
                return t.insert = 0, e === et ? (Tt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (Tt(t, !1), 0 === t.strm.avail_out) ? 1 : 2;
            })(i, e) : Nt[i.level].func(i, e);
            if (3 !== r && 4 !== r || (i.status = bt), 1 === r || 3 === r) return 0 === t.avail_out && (i.last_flush = -1), rt;
            if (2 === r && (e === V ? Y(i) : e !== it && (J(i, 0, 0, !1), e === tt && (xt(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), St(t), 0 === t.avail_out)) return i.last_flush = -1, rt;
        }
        return e !== et ? rt : i.wrap <= 0 ? nt : (2 === i.wrap ? (Ft(i, 255 & t.adler), Ft(i, t.adler >> 8 & 255), Ft(i, t.adler >> 16 & 255), Ft(i, t.adler >> 24 & 255), Ft(i, 255 & t.total_in), Ft(i, t.total_in >> 8 & 255), Ft(i, t.total_in >> 16 & 255), Ft(i, t.total_in >> 24 & 255)) : (It(i, t.adler >>> 16), It(i, 65535 & t.adler)), St(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? rt : nt);
    },
    deflateEnd: (t)=>{
        if (Ot(t)) return st;
        const e = t.state.status;
        return t.state = null, e === yt ? vt(t, at) : rt;
    },
    deflateSetDictionary: (t, e)=>{
        let i = e.length;
        if (Ot(t)) return st;
        const r = t.state, n = r.wrap;
        if (2 === n || 1 === n && r.status !== gt || r.lookahead) return st;
        if (1 === n && (t.adler = $(t.adler, e, i, 0)), r.wrap = 0, i >= r.w_size) {
            0 === n && (xt(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0);
            let t = new Uint8Array(r.w_size);
            t.set(e.subarray(i - r.w_size, i), 0), e = t, i = r.w_size;
        }
        const s = t.avail_in, a = t.next_in, o = t.input;
        for(t.avail_in = i, t.next_in = 0, t.input = e, Bt(r); r.lookahead >= 3;){
            let t = r.strstart, e = r.lookahead - 2;
            do r.ins_h = At(r, r.ins_h, r.window[t + 3 - 1]), r.prev[t & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = t, t++;
            while (--e);
            r.strstart = t, r.lookahead = 2, Bt(r);
        }
        return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = 2, r.match_available = 0, t.next_in = a, t.input = o, t.avail_in = s, r.wrap = n, rt;
    },
    deflateInfo: "pako deflate (from Nodeca project)"
};
const Ht = (t, e)=>Object.prototype.hasOwnProperty.call(t, e);
var Wt = {
    assign: function(t) {
        const e = Array.prototype.slice.call(arguments, 1);
        for(; e.length;){
            const i = e.shift();
            if (i) {
                if ("object" != typeof i) throw new TypeError(i + "must be non-object");
                for(const e in i)Ht(i, e) && (t[e] = i[e]);
            }
        }
        return t;
    },
    flattenChunks: (t)=>{
        let e = 0;
        for(let i = 0, r = t.length; i < r; i++)e += t[i].length;
        const i = new Uint8Array(e);
        for(let e = 0, r = 0, n = t.length; e < n; e++){
            let n = t[e];
            i.set(n, r), r += n.length;
        }
        return i;
    }
};
let qt = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1));
} catch (t) {
    qt = !1;
}
const Kt = new Uint8Array(256);
for(let t = 0; t < 256; t++)Kt[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
Kt[254] = Kt[254] = 1;
var Jt = {
    string2buf: (t)=>{
        if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(t);
        let e, i, r, n, s, a = t.length, o = 0;
        for(n = 0; n < a; n++)i = t.charCodeAt(n), 55296 == (64512 & i) && n + 1 < a && (r = t.charCodeAt(n + 1), 56320 == (64512 & r) && (i = 65536 + (i - 55296 << 10) + (r - 56320), n++)), o += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4;
        for(e = new Uint8Array(o), s = 0, n = 0; s < o; n++)i = t.charCodeAt(n), 55296 == (64512 & i) && n + 1 < a && (r = t.charCodeAt(n + 1), 56320 == (64512 & r) && (i = 65536 + (i - 55296 << 10) + (r - 56320), n++)), i < 128 ? e[s++] = i : i < 2048 ? (e[s++] = 192 | i >>> 6, e[s++] = 128 | 63 & i) : i < 65536 ? (e[s++] = 224 | i >>> 12, e[s++] = 128 | i >>> 6 & 63, e[s++] = 128 | 63 & i) : (e[s++] = 240 | i >>> 18, e[s++] = 128 | i >>> 12 & 63, e[s++] = 128 | i >>> 6 & 63, e[s++] = 128 | 63 & i);
        return e;
    },
    buf2string: (t, e)=>{
        const i = e || t.length;
        if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(t.subarray(0, e));
        let r, n;
        const s = new Array(2 * i);
        for(n = 0, r = 0; r < i;){
            let e = t[r++];
            if (e < 128) {
                s[n++] = e;
                continue;
            }
            let a = Kt[e];
            if (a > 4) s[n++] = 65533, r += a - 1;
            else {
                for(e &= 2 === a ? 31 : 3 === a ? 15 : 7; a > 1 && r < i;)e = e << 6 | 63 & t[r++], a--;
                a > 1 ? s[n++] = 65533 : e < 65536 ? s[n++] = e : (e -= 65536, s[n++] = 55296 | e >> 10 & 1023, s[n++] = 56320 | 1023 & e);
            }
        }
        return ((t, e)=>{
            if (e < 65534 && t.subarray && qt) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e));
            let i = "";
            for(let r = 0; r < e; r++)i += String.fromCharCode(t[r]);
            return i;
        })(s, n);
    },
    utf8border: (t, e)=>{
        (e = e || t.length) > t.length && (e = t.length);
        let i = e - 1;
        for(; i >= 0 && 128 == (192 & t[i]);)i--;
        return i < 0 || 0 === i ? e : i + Kt[t[i]] > e ? i : e;
    }
};
var Gt = function() {
    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
};
const Xt = Object.prototype.toString, { Z_NO_FLUSH: Yt, Z_SYNC_FLUSH: Qt, Z_FULL_FLUSH: Vt, Z_FINISH: te, Z_OK: ee, Z_STREAM_END: ie, Z_DEFAULT_COMPRESSION: re, Z_DEFAULT_STRATEGY: ne, Z_DEFLATED: se } = q;
function ae(t) {
    this.options = Wt.assign({
        level: re,
        method: se,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: ne
    }, t || {});
    let e = this.options;
    e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Gt, this.strm.avail_out = 0;
    let i = jt.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy);
    if (i !== ee) throw new Error(W[i]);
    if (e.header && jt.deflateSetHeader(this.strm, e.header), e.dictionary) {
        let t;
        if (t = "string" == typeof e.dictionary ? Jt.string2buf(e.dictionary) : "[object ArrayBuffer]" === Xt.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, i = jt.deflateSetDictionary(this.strm, t), i !== ee) throw new Error(W[i]);
        this._dict_set = !0;
    }
}
function oe(t, e) {
    const i = new ae(e);
    if (i.push(t, !0), i.err) throw i.msg || W[i.err];
    return i.result;
}
ae.prototype.push = function(t, e) {
    const i = this.strm, r = this.options.chunkSize;
    let n, s;
    if (this.ended) return !1;
    for(s = e === ~~e ? e : !0 === e ? te : Yt, "string" == typeof t ? i.input = Jt.string2buf(t) : "[object ArrayBuffer]" === Xt.call(t) ? i.input = new Uint8Array(t) : i.input = t, i.next_in = 0, i.avail_in = i.input.length;;)if (0 === i.avail_out && (i.output = new Uint8Array(r), i.next_out = 0, i.avail_out = r), (s === Qt || s === Vt) && i.avail_out <= 6) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;
    else {
        if (n = jt.deflate(i, s), n === ie) return i.next_out > 0 && this.onData(i.output.subarray(0, i.next_out)), n = jt.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === ee;
        if (0 !== i.avail_out) {
            if (s > 0 && i.next_out > 0) this.onData(i.output.subarray(0, i.next_out)), i.avail_out = 0;
            else if (0 === i.avail_in) break;
        } else this.onData(i.output);
    }
    return !0;
}, ae.prototype.onData = function(t) {
    this.chunks.push(t);
}, ae.prototype.onEnd = function(t) {
    t === ee && (this.result = Wt.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
var le = {
    Deflate: ae,
    deflate: oe,
    deflateRaw: function(t, e) {
        return (e = e || {}).raw = !0, oe(t, e);
    },
    gzip: function(t, e) {
        return (e = e || {}).gzip = !0, oe(t, e);
    },
    constants: q
};
const he = 16209;
var de = function(t, e) {
    let i, r, n, s, a, o, l, h, d, u, f, c, _, w, p, m, g, y, b, v, k, x, z, A;
    const S = t.state;
    i = t.next_in, z = t.input, r = i + (t.avail_in - 5), n = t.next_out, A = t.output, s = n - (e - t.avail_out), a = n + (t.avail_out - 257), o = S.dmax, l = S.wsize, h = S.whave, d = S.wnext, u = S.window, f = S.hold, c = S.bits, _ = S.lencode, w = S.distcode, p = (1 << S.lenbits) - 1, m = (1 << S.distbits) - 1;
    t: do {
        c < 15 && (f += z[i++] << c, c += 8, f += z[i++] << c, c += 8), g = _[f & p];
        e: for(;;){
            if (y = g >>> 24, f >>>= y, c -= y, y = g >>> 16 & 255, 0 === y) A[n++] = 65535 & g;
            else {
                if (!(16 & y)) {
                    if (0 == (64 & y)) {
                        g = _[(65535 & g) + (f & (1 << y) - 1)];
                        continue e;
                    }
                    if (32 & y) {
                        S.mode = 16191;
                        break t;
                    }
                    t.msg = "invalid literal/length code", S.mode = he;
                    break t;
                }
                b = 65535 & g, y &= 15, y && (c < y && (f += z[i++] << c, c += 8), b += f & (1 << y) - 1, f >>>= y, c -= y), c < 15 && (f += z[i++] << c, c += 8, f += z[i++] << c, c += 8), g = w[f & m];
                i: for(;;){
                    if (y = g >>> 24, f >>>= y, c -= y, y = g >>> 16 & 255, !(16 & y)) {
                        if (0 == (64 & y)) {
                            g = w[(65535 & g) + (f & (1 << y) - 1)];
                            continue i;
                        }
                        t.msg = "invalid distance code", S.mode = he;
                        break t;
                    }
                    if (v = 65535 & g, y &= 15, c < y && (f += z[i++] << c, c += 8, c < y && (f += z[i++] << c, c += 8)), v += f & (1 << y) - 1, v > o) {
                        t.msg = "invalid distance too far back", S.mode = he;
                        break t;
                    }
                    if (f >>>= y, c -= y, y = n - s, v > y) {
                        if (y = v - y, y > h && S.sane) {
                            t.msg = "invalid distance too far back", S.mode = he;
                            break t;
                        }
                        if (k = 0, x = u, 0 === d) {
                            if (k += l - y, y < b) {
                                b -= y;
                                do A[n++] = u[k++];
                                while (--y);
                                k = n - v, x = A;
                            }
                        } else if (d < y) {
                            if (k += l + d - y, y -= d, y < b) {
                                b -= y;
                                do A[n++] = u[k++];
                                while (--y);
                                if (k = 0, d < b) {
                                    y = d, b -= y;
                                    do A[n++] = u[k++];
                                    while (--y);
                                    k = n - v, x = A;
                                }
                            }
                        } else if (k += d - y, y < b) {
                            b -= y;
                            do A[n++] = u[k++];
                            while (--y);
                            k = n - v, x = A;
                        }
                        for(; b > 2;)A[n++] = x[k++], A[n++] = x[k++], A[n++] = x[k++], b -= 3;
                        b && (A[n++] = x[k++], b > 1 && (A[n++] = x[k++]));
                    } else {
                        k = n - v;
                        do A[n++] = A[k++], A[n++] = A[k++], A[n++] = A[k++], b -= 3;
                        while (b > 2);
                        b && (A[n++] = A[k++], b > 1 && (A[n++] = A[k++]));
                    }
                    break;
                }
            }
            break;
        }
    }while (i < r && n < a);
    b = c >> 3, i -= b, c -= b << 3, f &= (1 << c) - 1, t.next_in = i, t.next_out = n, t.avail_in = i < r ? r - i + 5 : 5 - (i - r), t.avail_out = n < a ? a - n + 257 : 257 - (n - a), S.hold = f, S.bits = c;
};
const ue = 15, fe = new Uint16Array([
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
]), ce = new Uint8Array([
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
]), _e = new Uint16Array([
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
]), we = new Uint8Array([
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
]);
var pe = (t, e, i, r, n, s, a, o)=>{
    const l = o.bits;
    let h, d, u, f, c, _, w = 0, p = 0, m = 0, g = 0, y = 0, b = 0, v = 0, k = 0, x = 0, z = 0, A = null;
    const S = new Uint16Array(16), T = new Uint16Array(16);
    let F, I, E, C = null;
    for(w = 0; w <= ue; w++)S[w] = 0;
    for(p = 0; p < r; p++)S[e[i + p]]++;
    for(y = l, g = ue; g >= 1 && 0 === S[g]; g--);
    if (y > g && (y = g), 0 === g) return n[s++] = 20971520, n[s++] = 20971520, o.bits = 1, 0;
    for(m = 1; m < g && 0 === S[m]; m++);
    for(y < m && (y = m), k = 1, w = 1; w <= ue; w++)if (k <<= 1, k -= S[w], k < 0) return -1;
    if (k > 0 && (0 === t || 1 !== g)) return -1;
    for(T[1] = 0, w = 1; w < ue; w++)T[w + 1] = T[w] + S[w];
    for(p = 0; p < r; p++)0 !== e[i + p] && (a[T[e[i + p]]++] = p);
    if (0 === t ? (A = C = a, _ = 20) : 1 === t ? (A = fe, C = ce, _ = 257) : (A = _e, C = we, _ = 0), z = 0, p = 0, w = m, c = s, b = y, v = 0, u = -1, x = 1 << y, f = x - 1, 1 === t && x > 852 || 2 === t && x > 592) return 1;
    for(;;){
        F = w - v, a[p] + 1 < _ ? (I = 0, E = a[p]) : a[p] >= _ ? (I = C[a[p] - _], E = A[a[p] - _]) : (I = 96, E = 0), h = 1 << w - v, d = 1 << b, m = d;
        do d -= h, n[c + (z >> v) + d] = F << 24 | I << 16 | E | 0;
        while (0 !== d);
        for(h = 1 << w - 1; z & h;)h >>= 1;
        if (0 !== h ? (z &= h - 1, z += h) : z = 0, p++, 0 == --S[w]) {
            if (w === g) break;
            w = e[i + a[p]];
        }
        if (w > y && (z & f) !== u) {
            for(0 === v && (v = y), c += m, b = w - v, k = 1 << b; b + v < g && (k -= S[b + v], !(k <= 0));)b++, k <<= 1;
            if (x += 1 << b, 1 === t && x > 852 || 2 === t && x > 592) return 1;
            u = z & f, n[u] = y << 24 | b << 16 | c - s | 0;
        }
    }
    return 0 !== z && (n[c + z] = w - v << 24 | 4194304), o.bits = y, 0;
};
const { Z_FINISH: me, Z_BLOCK: ge, Z_TREES: ye, Z_OK: be, Z_STREAM_END: ve, Z_NEED_DICT: ke, Z_STREAM_ERROR: xe, Z_DATA_ERROR: ze, Z_MEM_ERROR: Ae, Z_BUF_ERROR: Se, Z_DEFLATED: Te } = q, Fe = 16180, Ie = 16190, Ee = 16191, Ce = 16192, Be = 16194, De = 16199, Re = 16200, Ue = 16206, Le = 16209, Ne = (t)=>(t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24);
function Pe() {
    this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
}
const Oe = (t)=>{
    if (!t) return 1;
    const e = t.state;
    return !e || e.strm !== t || e.mode < Fe || e.mode > 16211 ? 1 : 0;
}, Ze = (t)=>{
    if (Oe(t)) return xe;
    const e = t.state;
    return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = Fe, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(852), e.distcode = e.distdyn = new Int32Array(592), e.sane = 1, e.back = -1, be;
}, Me = (t)=>{
    if (Oe(t)) return xe;
    const e = t.state;
    return e.wsize = 0, e.whave = 0, e.wnext = 0, Ze(t);
}, $e = (t, e)=>{
    let i;
    if (Oe(t)) return xe;
    const r = t.state;
    return e < 0 ? (i = 0, e = -e) : (i = 5 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? xe : (null !== r.window && r.wbits !== e && (r.window = null), r.wrap = i, r.wbits = e, Me(t));
}, je = (t, e)=>{
    if (!t) return xe;
    const i = new Pe;
    t.state = i, i.strm = t, i.window = null, i.mode = Fe;
    const r = $e(t, e);
    return r !== be && (t.state = null), r;
};
let He, We, qe = !0;
const Ke = (t)=>{
    if (qe) {
        He = new Int32Array(512), We = new Int32Array(32);
        let e = 0;
        for(; e < 144;)t.lens[e++] = 8;
        for(; e < 256;)t.lens[e++] = 9;
        for(; e < 280;)t.lens[e++] = 7;
        for(; e < 288;)t.lens[e++] = 8;
        for(pe(1, t.lens, 0, 288, He, 0, t.work, {
            bits: 9
        }), e = 0; e < 32;)t.lens[e++] = 5;
        pe(2, t.lens, 0, 32, We, 0, t.work, {
            bits: 5
        }), qe = !1;
    }
    t.lencode = He, t.lenbits = 9, t.distcode = We, t.distbits = 5;
}, Je = (t, e, i, r)=>{
    let n;
    const s = t.state;
    return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new Uint8Array(s.wsize)), r >= s.wsize ? (s.window.set(e.subarray(i - s.wsize, i), 0), s.wnext = 0, s.whave = s.wsize) : (n = s.wsize - s.wnext, n > r && (n = r), s.window.set(e.subarray(i - r, i - r + n), s.wnext), (r -= n) ? (s.window.set(e.subarray(i - r, i), 0), s.wnext = r, s.whave = s.wsize) : (s.wnext += n, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += n))), 0;
};
var Ge = (t, e)=>{
    let i, r, n, s, a, o, l, h, d, u, f, c, _, w, p, m, g, y, b, v, k, x, z = 0;
    const A = new Uint8Array(4);
    let S, T;
    const F = new Uint8Array([
        16,
        17,
        18,
        0,
        8,
        7,
        9,
        6,
        10,
        5,
        11,
        4,
        12,
        3,
        13,
        2,
        14,
        1,
        15
    ]);
    if (Oe(t) || !t.output || !t.input && 0 !== t.avail_in) return xe;
    i = t.state, i.mode === Ee && (i.mode = Ce), a = t.next_out, n = t.output, l = t.avail_out, s = t.next_in, r = t.input, o = t.avail_in, h = i.hold, d = i.bits, u = o, f = l, x = be;
    t: for(;;)switch(i.mode){
        case Fe:
            if (0 === i.wrap) {
                i.mode = Ce;
                break;
            }
            for(; d < 16;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if (2 & i.wrap && 35615 === h) {
                0 === i.wbits && (i.wbits = 15), i.check = 0, A[0] = 255 & h, A[1] = h >>> 8 & 255, i.check = H(i.check, A, 2, 0), h = 0, d = 0, i.mode = 16181;
                break;
            }
            if (i.head && (i.head.done = !1), !(1 & i.wrap) || (((255 & h) << 8) + (h >> 8)) % 31) {
                t.msg = "incorrect header check", i.mode = Le;
                break;
            }
            if ((15 & h) !== Te) {
                t.msg = "unknown compression method", i.mode = Le;
                break;
            }
            if (h >>>= 4, d -= 4, k = 8 + (15 & h), 0 === i.wbits && (i.wbits = k), k > 15 || k > i.wbits) {
                t.msg = "invalid window size", i.mode = Le;
                break;
            }
            i.dmax = 1 << i.wbits, i.flags = 0, t.adler = i.check = 1, i.mode = 512 & h ? 16189 : Ee, h = 0, d = 0;
            break;
        case 16181:
            for(; d < 16;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if (i.flags = h, (255 & i.flags) !== Te) {
                t.msg = "unknown compression method", i.mode = Le;
                break;
            }
            if (57344 & i.flags) {
                t.msg = "unknown header flags set", i.mode = Le;
                break;
            }
            i.head && (i.head.text = h >> 8 & 1), 512 & i.flags && 4 & i.wrap && (A[0] = 255 & h, A[1] = h >>> 8 & 255, i.check = H(i.check, A, 2, 0)), h = 0, d = 0, i.mode = 16182;
        case 16182:
            for(; d < 32;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            i.head && (i.head.time = h), 512 & i.flags && 4 & i.wrap && (A[0] = 255 & h, A[1] = h >>> 8 & 255, A[2] = h >>> 16 & 255, A[3] = h >>> 24 & 255, i.check = H(i.check, A, 4, 0)), h = 0, d = 0, i.mode = 16183;
        case 16183:
            for(; d < 16;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            i.head && (i.head.xflags = 255 & h, i.head.os = h >> 8), 512 & i.flags && 4 & i.wrap && (A[0] = 255 & h, A[1] = h >>> 8 & 255, i.check = H(i.check, A, 2, 0)), h = 0, d = 0, i.mode = 16184;
        case 16184:
            if (1024 & i.flags) {
                for(; d < 16;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                i.length = h, i.head && (i.head.extra_len = h), 512 & i.flags && 4 & i.wrap && (A[0] = 255 & h, A[1] = h >>> 8 & 255, i.check = H(i.check, A, 2, 0)), h = 0, d = 0;
            } else i.head && (i.head.extra = null);
            i.mode = 16185;
        case 16185:
            if (1024 & i.flags && (c = i.length, c > o && (c = o), c && (i.head && (k = i.head.extra_len - i.length, i.head.extra || (i.head.extra = new Uint8Array(i.head.extra_len)), i.head.extra.set(r.subarray(s, s + c), k)), 512 & i.flags && 4 & i.wrap && (i.check = H(i.check, r, c, s)), o -= c, s += c, i.length -= c), i.length)) break t;
            i.length = 0, i.mode = 16186;
        case 16186:
            if (2048 & i.flags) {
                if (0 === o) break t;
                c = 0;
                do k = r[s + c++], i.head && k && i.length < 65536 && (i.head.name += String.fromCharCode(k));
                while (k && c < o);
                if (512 & i.flags && 4 & i.wrap && (i.check = H(i.check, r, c, s)), o -= c, s += c, k) break t;
            } else i.head && (i.head.name = null);
            i.length = 0, i.mode = 16187;
        case 16187:
            if (4096 & i.flags) {
                if (0 === o) break t;
                c = 0;
                do k = r[s + c++], i.head && k && i.length < 65536 && (i.head.comment += String.fromCharCode(k));
                while (k && c < o);
                if (512 & i.flags && 4 & i.wrap && (i.check = H(i.check, r, c, s)), o -= c, s += c, k) break t;
            } else i.head && (i.head.comment = null);
            i.mode = 16188;
        case 16188:
            if (512 & i.flags) {
                for(; d < 16;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                if (4 & i.wrap && h !== (65535 & i.check)) {
                    t.msg = "header crc mismatch", i.mode = Le;
                    break;
                }
                h = 0, d = 0;
            }
            i.head && (i.head.hcrc = i.flags >> 9 & 1, i.head.done = !0), t.adler = i.check = 0, i.mode = Ee;
            break;
        case 16189:
            for(; d < 32;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            t.adler = i.check = Ne(h), h = 0, d = 0, i.mode = Ie;
        case Ie:
            if (0 === i.havedict) return t.next_out = a, t.avail_out = l, t.next_in = s, t.avail_in = o, i.hold = h, i.bits = d, ke;
            t.adler = i.check = 1, i.mode = Ee;
        case Ee:
            if (e === ge || e === ye) break t;
        case Ce:
            if (i.last) {
                h >>>= 7 & d, d -= 7 & d, i.mode = Ue;
                break;
            }
            for(; d < 3;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            switch(i.last = 1 & h, h >>>= 1, d -= 1, 3 & h){
                case 0:
                    i.mode = 16193;
                    break;
                case 1:
                    if (Ke(i), i.mode = De, e === ye) {
                        h >>>= 2, d -= 2;
                        break t;
                    }
                    break;
                case 2:
                    i.mode = 16196;
                    break;
                case 3:
                    t.msg = "invalid block type", i.mode = Le;
            }
            h >>>= 2, d -= 2;
            break;
        case 16193:
            for(h >>>= 7 & d, d -= 7 & d; d < 32;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if ((65535 & h) != (h >>> 16 ^ 65535)) {
                t.msg = "invalid stored block lengths", i.mode = Le;
                break;
            }
            if (i.length = 65535 & h, h = 0, d = 0, i.mode = Be, e === ye) break t;
        case Be:
            i.mode = 16195;
        case 16195:
            if (c = i.length, c) {
                if (c > o && (c = o), c > l && (c = l), 0 === c) break t;
                n.set(r.subarray(s, s + c), a), o -= c, s += c, l -= c, a += c, i.length -= c;
                break;
            }
            i.mode = Ee;
            break;
        case 16196:
            for(; d < 14;){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if (i.nlen = 257 + (31 & h), h >>>= 5, d -= 5, i.ndist = 1 + (31 & h), h >>>= 5, d -= 5, i.ncode = 4 + (15 & h), h >>>= 4, d -= 4, i.nlen > 286 || i.ndist > 30) {
                t.msg = "too many length or distance symbols", i.mode = Le;
                break;
            }
            i.have = 0, i.mode = 16197;
        case 16197:
            for(; i.have < i.ncode;){
                for(; d < 3;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                i.lens[F[i.have++]] = 7 & h, h >>>= 3, d -= 3;
            }
            for(; i.have < 19;)i.lens[F[i.have++]] = 0;
            if (i.lencode = i.lendyn, i.lenbits = 7, S = {
                bits: i.lenbits
            }, x = pe(0, i.lens, 0, 19, i.lencode, 0, i.work, S), i.lenbits = S.bits, x) {
                t.msg = "invalid code lengths set", i.mode = Le;
                break;
            }
            i.have = 0, i.mode = 16198;
        case 16198:
            for(; i.have < i.nlen + i.ndist;){
                for(; z = i.lencode[h & (1 << i.lenbits) - 1], p = z >>> 24, m = z >>> 16 & 255, g = 65535 & z, !(p <= d);){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                if (g < 16) h >>>= p, d -= p, i.lens[i.have++] = g;
                else {
                    if (16 === g) {
                        for(T = p + 2; d < T;){
                            if (0 === o) break t;
                            o--, h += r[s++] << d, d += 8;
                        }
                        if (h >>>= p, d -= p, 0 === i.have) {
                            t.msg = "invalid bit length repeat", i.mode = Le;
                            break;
                        }
                        k = i.lens[i.have - 1], c = 3 + (3 & h), h >>>= 2, d -= 2;
                    } else if (17 === g) {
                        for(T = p + 3; d < T;){
                            if (0 === o) break t;
                            o--, h += r[s++] << d, d += 8;
                        }
                        h >>>= p, d -= p, k = 0, c = 3 + (7 & h), h >>>= 3, d -= 3;
                    } else {
                        for(T = p + 7; d < T;){
                            if (0 === o) break t;
                            o--, h += r[s++] << d, d += 8;
                        }
                        h >>>= p, d -= p, k = 0, c = 11 + (127 & h), h >>>= 7, d -= 7;
                    }
                    if (i.have + c > i.nlen + i.ndist) {
                        t.msg = "invalid bit length repeat", i.mode = Le;
                        break;
                    }
                    for(; c--;)i.lens[i.have++] = k;
                }
            }
            if (i.mode === Le) break;
            if (0 === i.lens[256]) {
                t.msg = "invalid code -- missing end-of-block", i.mode = Le;
                break;
            }
            if (i.lenbits = 9, S = {
                bits: i.lenbits
            }, x = pe(1, i.lens, 0, i.nlen, i.lencode, 0, i.work, S), i.lenbits = S.bits, x) {
                t.msg = "invalid literal/lengths set", i.mode = Le;
                break;
            }
            if (i.distbits = 6, i.distcode = i.distdyn, S = {
                bits: i.distbits
            }, x = pe(2, i.lens, i.nlen, i.ndist, i.distcode, 0, i.work, S), i.distbits = S.bits, x) {
                t.msg = "invalid distances set", i.mode = Le;
                break;
            }
            if (i.mode = De, e === ye) break t;
        case De:
            i.mode = Re;
        case Re:
            if (o >= 6 && l >= 258) {
                t.next_out = a, t.avail_out = l, t.next_in = s, t.avail_in = o, i.hold = h, i.bits = d, de(t, f), a = t.next_out, n = t.output, l = t.avail_out, s = t.next_in, r = t.input, o = t.avail_in, h = i.hold, d = i.bits, i.mode === Ee && (i.back = -1);
                break;
            }
            for(i.back = 0; z = i.lencode[h & (1 << i.lenbits) - 1], p = z >>> 24, m = z >>> 16 & 255, g = 65535 & z, !(p <= d);){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if (m && 0 == (240 & m)) {
                for(y = p, b = m, v = g; z = i.lencode[v + ((h & (1 << y + b) - 1) >> y)], p = z >>> 24, m = z >>> 16 & 255, g = 65535 & z, !(y + p <= d);){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                h >>>= y, d -= y, i.back += y;
            }
            if (h >>>= p, d -= p, i.back += p, i.length = g, 0 === m) {
                i.mode = 16205;
                break;
            }
            if (32 & m) {
                i.back = -1, i.mode = Ee;
                break;
            }
            if (64 & m) {
                t.msg = "invalid literal/length code", i.mode = Le;
                break;
            }
            i.extra = 15 & m, i.mode = 16201;
        case 16201:
            if (i.extra) {
                for(T = i.extra; d < T;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                i.length += h & (1 << i.extra) - 1, h >>>= i.extra, d -= i.extra, i.back += i.extra;
            }
            i.was = i.length, i.mode = 16202;
        case 16202:
            for(; z = i.distcode[h & (1 << i.distbits) - 1], p = z >>> 24, m = z >>> 16 & 255, g = 65535 & z, !(p <= d);){
                if (0 === o) break t;
                o--, h += r[s++] << d, d += 8;
            }
            if (0 == (240 & m)) {
                for(y = p, b = m, v = g; z = i.distcode[v + ((h & (1 << y + b) - 1) >> y)], p = z >>> 24, m = z >>> 16 & 255, g = 65535 & z, !(y + p <= d);){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                h >>>= y, d -= y, i.back += y;
            }
            if (h >>>= p, d -= p, i.back += p, 64 & m) {
                t.msg = "invalid distance code", i.mode = Le;
                break;
            }
            i.offset = g, i.extra = 15 & m, i.mode = 16203;
        case 16203:
            if (i.extra) {
                for(T = i.extra; d < T;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                i.offset += h & (1 << i.extra) - 1, h >>>= i.extra, d -= i.extra, i.back += i.extra;
            }
            if (i.offset > i.dmax) {
                t.msg = "invalid distance too far back", i.mode = Le;
                break;
            }
            i.mode = 16204;
        case 16204:
            if (0 === l) break t;
            if (c = f - l, i.offset > c) {
                if (c = i.offset - c, c > i.whave && i.sane) {
                    t.msg = "invalid distance too far back", i.mode = Le;
                    break;
                }
                c > i.wnext ? (c -= i.wnext, _ = i.wsize - c) : _ = i.wnext - c, c > i.length && (c = i.length), w = i.window;
            } else w = n, _ = a - i.offset, c = i.length;
            c > l && (c = l), l -= c, i.length -= c;
            do n[a++] = w[_++];
            while (--c);
            0 === i.length && (i.mode = Re);
            break;
        case 16205:
            if (0 === l) break t;
            n[a++] = i.length, l--, i.mode = Re;
            break;
        case Ue:
            if (i.wrap) {
                for(; d < 32;){
                    if (0 === o) break t;
                    o--, h |= r[s++] << d, d += 8;
                }
                if (f -= l, t.total_out += f, i.total += f, 4 & i.wrap && f && (t.adler = i.check = i.flags ? H(i.check, n, f, a - f) : $(i.check, n, f, a - f)), f = l, 4 & i.wrap && (i.flags ? h : Ne(h)) !== i.check) {
                    t.msg = "incorrect data check", i.mode = Le;
                    break;
                }
                h = 0, d = 0;
            }
            i.mode = 16207;
        case 16207:
            if (i.wrap && i.flags) {
                for(; d < 32;){
                    if (0 === o) break t;
                    o--, h += r[s++] << d, d += 8;
                }
                if (4 & i.wrap && h !== (4294967295 & i.total)) {
                    t.msg = "incorrect length check", i.mode = Le;
                    break;
                }
                h = 0, d = 0;
            }
            i.mode = 16208;
        case 16208:
            x = ve;
            break t;
        case Le:
            x = ze;
            break t;
        case 16210:
            return Ae;
        default:
            return xe;
    }
    return t.next_out = a, t.avail_out = l, t.next_in = s, t.avail_in = o, i.hold = h, i.bits = d, (i.wsize || f !== t.avail_out && i.mode < Le && (i.mode < Ue || e !== me)) && Je(t, t.output, t.next_out, f - t.avail_out), u -= t.avail_in, f -= t.avail_out, t.total_in += u, t.total_out += f, i.total += f, 4 & i.wrap && f && (t.adler = i.check = i.flags ? H(i.check, n, f, t.next_out - f) : $(i.check, n, f, t.next_out - f)), t.data_type = i.bits + (i.last ? 64 : 0) + (i.mode === Ee ? 128 : 0) + (i.mode === De || i.mode === Be ? 256 : 0), (0 === u && 0 === f || e === me) && x === be && (x = Se), x;
}, Xe = {
    inflateReset: Me,
    inflateReset2: $e,
    inflateResetKeep: Ze,
    inflateInit: (t)=>je(t, 15),
    inflateInit2: je,
    inflate: Ge,
    inflateEnd: (t)=>{
        if (Oe(t)) return xe;
        let e = t.state;
        return e.window && (e.window = null), t.state = null, be;
    },
    inflateGetHeader: (t, e)=>{
        if (Oe(t)) return xe;
        const i = t.state;
        return 0 == (2 & i.wrap) ? xe : (i.head = e, e.done = !1, be);
    },
    inflateSetDictionary: (t, e)=>{
        const i = e.length;
        let r, n, s;
        return Oe(t) ? xe : (r = t.state, 0 !== r.wrap && r.mode !== Ie ? xe : r.mode === Ie && (n = 1, n = $(n, e, i, 0), n !== r.check) ? ze : (s = Je(t, e, i, i), s ? (r.mode = 16210, Ae) : (r.havedict = 1, be)));
    },
    inflateInfo: "pako inflate (from Nodeca project)"
};
var Ye = function() {
    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
};
const Qe = Object.prototype.toString, { Z_NO_FLUSH: Ve, Z_FINISH: ti, Z_OK: ei, Z_STREAM_END: ii, Z_NEED_DICT: ri, Z_STREAM_ERROR: ni, Z_DATA_ERROR: si, Z_MEM_ERROR: ai } = q;
function oi(t) {
    this.options = Wt.assign({
        chunkSize: 65536,
        windowBits: 15,
        to: ""
    }, t || {});
    const e = this.options;
    e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && 0 == (15 & e.windowBits) && (e.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Gt, this.strm.avail_out = 0;
    let i = Xe.inflateInit2(this.strm, e.windowBits);
    if (i !== ei) throw new Error(W[i]);
    if (this.header = new Ye, Xe.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = Jt.string2buf(e.dictionary) : "[object ArrayBuffer]" === Qe.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (i = Xe.inflateSetDictionary(this.strm, e.dictionary), i !== ei))) throw new Error(W[i]);
}
function li(t, e) {
    const i = new oi(e);
    if (i.push(t), i.err) throw i.msg || W[i.err];
    return i.result;
}
oi.prototype.push = function(t, e) {
    const i = this.strm, r = this.options.chunkSize, n = this.options.dictionary;
    let s, a, o;
    if (this.ended) return !1;
    for(a = e === ~~e ? e : !0 === e ? ti : Ve, "[object ArrayBuffer]" === Qe.call(t) ? i.input = new Uint8Array(t) : i.input = t, i.next_in = 0, i.avail_in = i.input.length;;){
        for(0 === i.avail_out && (i.output = new Uint8Array(r), i.next_out = 0, i.avail_out = r), s = Xe.inflate(i, a), s === ri && n && (s = Xe.inflateSetDictionary(i, n), s === ei ? s = Xe.inflate(i, a) : s === si && (s = ri)); i.avail_in > 0 && s === ii && i.state.wrap > 0 && 0 !== t[i.next_in];)Xe.inflateReset(i), s = Xe.inflate(i, a);
        switch(s){
            case ni:
            case si:
            case ri:
            case ai:
                return this.onEnd(s), this.ended = !0, !1;
        }
        if (o = i.avail_out, i.next_out && (0 === i.avail_out || s === ii)) {
            if ("string" === this.options.to) {
                let t = Jt.utf8border(i.output, i.next_out), e = i.next_out - t, n = Jt.buf2string(i.output, t);
                i.next_out = e, i.avail_out = r - e, e && i.output.set(i.output.subarray(t, t + e), 0), this.onData(n);
            } else this.onData(i.output.length === i.next_out ? i.output : i.output.subarray(0, i.next_out));
        }
        if (s !== ei || 0 !== o) {
            if (s === ii) return s = Xe.inflateEnd(this.strm), this.onEnd(s), this.ended = !0, !0;
            if (0 === i.avail_in) break;
        }
    }
    return !0;
}, oi.prototype.onData = function(t) {
    this.chunks.push(t);
}, oi.prototype.onEnd = function(t) {
    t === ei && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Wt.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg;
};
var hi = {
    Inflate: oi,
    inflate: li,
    inflateRaw: function(t, e) {
        return (e = e || {}).raw = !0, li(t, e);
    },
    ungzip: li,
    constants: q
};
const { Deflate: di, deflate: ui, deflateRaw: fi, gzip: ci } = le, { Inflate: _i, inflate: wi, inflateRaw: pi, ungzip: mi } = hi;
for(var gi = {
    Deflate: di,
    deflate: ui,
    deflateRaw: fi,
    gzip: ci,
    Inflate: _i,
    inflate: wi,
    inflateRaw: pi,
    ungzip: mi,
    constants: q
}, yi = function(t) {
    var e, i, r = function(t) {
        var e = t.length;
        if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var i = t.indexOf("=");
        -1 === i && (i = e);
        var r = i === e ? 0 : 4 - i % 4;
        return [
            i,
            r
        ];
    }(t), n = r[0], s = r[1], a = new xi(function(t, e, i) {
        return 3 * (e + i) / 4 - i;
    }(0, n, s)), o = 0, l = s > 0 ? n - 4 : n;
    for(i = 0; i < l; i += 4)e = ki[t.charCodeAt(i)] << 18 | ki[t.charCodeAt(i + 1)] << 12 | ki[t.charCodeAt(i + 2)] << 6 | ki[t.charCodeAt(i + 3)], a[o++] = e >> 16 & 255, a[o++] = e >> 8 & 255, a[o++] = 255 & e;
    2 === s && (e = ki[t.charCodeAt(i)] << 2 | ki[t.charCodeAt(i + 1)] >> 4, a[o++] = 255 & e);
    1 === s && (e = ki[t.charCodeAt(i)] << 10 | ki[t.charCodeAt(i + 1)] << 4 | ki[t.charCodeAt(i + 2)] >> 2, a[o++] = e >> 8 & 255, a[o++] = 255 & e);
    return a;
}, bi = function(t) {
    for(var e, i = t.length, r = i % 3, n = [], s = 16383, a = 0, o = i - r; a < o; a += s)n.push(Si(t, a, a + s > o ? o : a + s));
    1 === r ? (e = t[i - 1], n.push(vi[e >> 2] + vi[e << 4 & 63] + "==")) : 2 === r && (e = (t[i - 2] << 8) + t[i - 1], n.push(vi[e >> 10] + vi[e >> 4 & 63] + vi[e << 2 & 63] + "="));
    return n.join("");
}, vi = [], ki = [], xi = "undefined" != typeof Uint8Array ? Uint8Array : Array, zi = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ai = 0; Ai < 64; ++Ai)vi[Ai] = zi[Ai], ki[zi.charCodeAt(Ai)] = Ai;
function Si(t, e, i) {
    for(var r, n, s = [], a = e; a < i; a += 3)r = (t[a] << 16 & 16711680) + (t[a + 1] << 8 & 65280) + (255 & t[a + 2]), s.push(vi[(n = r) >> 18 & 63] + vi[n >> 12 & 63] + vi[n >> 6 & 63] + vi[63 & n]);
    return s.join("");
}
ki["-".charCodeAt(0)] = 62, ki["_".charCodeAt(0)] = 63;
!function() {
    try {
        return "win32" === process.platform;
    } catch (t) {
        return !1;
    }
}();
const Ti = function() {
    try {
        if ("fs" === undefined("fs")) return require("f1457235f5818f6a"), !1;
    } catch (t) {}
    return !0;
}();
function Fi(t) {
    return Uint8Array.from(t, (t)=>t.charCodeAt(0));
}
function Ii(e, i = "binary") {
    return t(this, void 0, void 0, function*() {
        return "function" == typeof Buffer ? Buffer.from(e).toString(i) : new Promise((t)=>{
            const r = new FileReader;
            r.onloadend = ()=>t(r.result), "binary" == i ? r.readAsBinaryString(new Blob([
                e
            ])) : r.readAsText(new Blob([
                e
            ]), i);
        });
    });
}
const Ei = "function" == typeof Buffer;
function Ci(t) {
    const e = gi.deflate(t);
    return Ei ? Buffer.from(e).toString("base64") : bi(e);
}
function Bi(t) {
    let e;
    return e = Ei ? Buffer.from(t, "base64") : yi(t), gi.inflate(e);
}
class Di extends Error {
    constructor(t, e = null, i = !1){
        if ("fail" === e || "FAIL" === e || "EXIT" === e) try {
            t = (new TextDecoder).decode(Bi(t));
        } catch (e) {
            t = `decode [${t}] error: ${e}`;
        }
        else e && (t = `[TrzszError] ${e}: ${t}`);
        super(t), Object.setPrototypeOf(this, Di.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Di), this.name = "TrzszError", this.type = e, this.trace = i;
    }
    isTraceBack() {
        return "fail" !== this.type && "EXIT" !== this.type && this.trace;
    }
    isRemoteExit() {
        return "EXIT" === this.type;
    }
    isRemoteFail() {
        return "fail" === this.type || "FAIL" === this.type;
    }
    isStopAndDelete() {
        return "fail" === this.type && "Stopped and deleted" === this.message;
    }
    static getErrorMessage(t) {
        return t instanceof Di && !t.isTraceBack() ? t.message : t.stack ? t.stack.replace("TrzszError: ", "") : t.toString();
    }
}
function Ri(t) {
    return 97 <= t && t <= 122 || 65 <= t && t <= 90;
}
const Ui = 1;
function Li(t, e) {
    let i = `Saved ${t.length} ${t.length > 1 ? "files/directories" : "file/directory"}`;
    return e.length > 0 && (i += ` to ${e}`), [
        i
    ].concat(t).join("\r\n- ");
}
const Ni = Oi("fs"), Pi = Oi("path");
function Oi(t) {
    try {
        return require(t);
    } catch (t) {
        return {};
    }
}
!function(t, e) {
    for (const i of e)t[i + "Async"] = (...e)=>new Promise((r)=>{
            t[i](...e, (t)=>r(!t));
        });
}(Ni, [
    "rm",
    "rmdir",
    "unlink",
    "access"
]), function(t, e) {
    for (const i of e)t[i + "Async"] = (...e)=>new Promise((r, n)=>{
            t[i](...e, (t, e)=>{
                t ? n(t) : r(e);
            });
        });
}(Ni, [
    "stat",
    "mkdir",
    "readdir",
    "close",
    "open",
    "realpath",
    "write"
]);
class Zi {
    constructor(t, e, i, r, n){
        this.closed = !1, this.fd = null, this.pathId = t, this.absPath = e, this.relPath = i, this.dir = r, this.size = n;
    }
    getPathId() {
        return this.pathId;
    }
    getRelPath() {
        return this.relPath;
    }
    isDir() {
        return this.dir;
    }
    getSize() {
        return this.size;
    }
    readFile(e) {
        return t(this, void 0, void 0, function*() {
            if (this.closed) throw new Di(`File closed: ${this.absPath}`, null, !0);
            null === this.fd && (this.fd = yield Ni.openAsync(this.absPath, "r"));
            const i = new Uint8Array(e);
            return function(e, i, r, n, s) {
                return t(this, void 0, void 0, function*() {
                    return new Promise((t, a)=>Ni.read(e, i, r, n, s, (e, i, r)=>{
                            e ? a(e) : t(r.subarray(0, i));
                        }));
                });
            }(this.fd, i, 0, i.length, null);
        });
    }
    closeFile() {
        return t(this, void 0, void 0, function*() {
            this.closed || (this.closed = !0, null !== this.fd && (yield Ni.closeAsync(this.fd), this.fd = null));
        });
    }
}
function Mi(e, i, r, n, s, a) {
    return t(this, void 0, void 0, function*() {
        if (!r.isDirectory()) {
            if (!r.isFile()) throw new Di(`Not a regular file: ${i}`);
            if (!(yield Ni.accessAsync(i, Ni.constants.R_OK))) throw new Di(`No permission to read: ${i}`);
            return void n.push(new Zi(e, i, s, !1, r.size));
        }
        const t = yield Ni.realpathAsync(i);
        if (a.has(t)) throw new Di(`Duplicate link: ${i}`);
        a.add(t), n.push(new Zi(e, i, s, !0, 0));
        const o = yield Ni.readdirAsync(i);
        for (const t of o){
            const r = Pi.join(i, t), o = yield Ni.statAsync(r);
            yield Mi(e, r, o, n, [
                ...s,
                t
            ], a);
        }
    });
}
function $i(e, i = !1) {
    return t(this, void 0, void 0, function*() {
        if (!e || !e.length) return;
        const t = [], r = e.entries();
        for (const [e, n] of r){
            const r = Pi.resolve(n);
            if (!(yield Ni.accessAsync(r))) throw new Di(`No such file: ${r}`);
            const s = yield Ni.statAsync(r);
            if (!i && s.isDirectory()) throw new Di(`Is a directory: ${r}`);
            const a = new Set;
            yield Mi(e, r, s, t, [
                Pi.basename(r)
            ], a);
        }
        return t;
    });
}
class ji {
    constructor(t, e, i, r, n = !1){
        this.closed = !1, this.absPath = t, this.fileName = e, this.localName = i, this.fd = r, this.dir = n;
    }
    getFileName() {
        return this.fileName;
    }
    getLocalName() {
        return this.localName;
    }
    isDir() {
        return this.dir;
    }
    writeFile(e) {
        return t(this, void 0, void 0, function*() {
            yield Ni.writeAsync(this.fd, e);
        });
    }
    closeFile() {
        return t(this, void 0, void 0, function*() {
            this.closed || (this.closed = !0, null !== this.fd && (yield Ni.closeAsync(this.fd), this.fd = null));
        });
    }
    deleteFile() {
        return t(this, void 0, void 0, function*() {
            if (!this.absPath || !(yield Ni.accessAsync(this.absPath))) return "";
            try {
                if (yield this.closeFile(), "function" == typeof Ni.rm) {
                    if (yield Ni.rmAsync(this.absPath, {
                        recursive: !0
                    })) return this.absPath;
                } else if (this.isDir) {
                    if (yield Ni.rmdirAsync(this.absPath, {
                        recursive: !0
                    })) return this.absPath;
                } else if (yield Ni.unlinkAsync(this.absPath)) return this.absPath;
            } catch (t) {
                console.log(`delete [${this.absPath}] failed`, t);
            }
            return "";
        });
    }
}
function Hi(e, i) {
    return t(this, void 0, void 0, function*() {
        if (!(yield Ni.accessAsync(Pi.join(e, i)))) return i;
        for(let t = 0; t < 1e3; t++){
            const r = `${i}.${t}`;
            if (!(yield Ni.accessAsync(Pi.join(e, r)))) return r;
        }
        throw new Di("Fail to assign new file name");
    });
}
function Wi(e) {
    return t(this, void 0, void 0, function*() {
        try {
            return yield Ni.openAsync(e, "w");
        } catch (t) {
            if (-13 === t.errno || -4048 === t.errno) throw new Di(`No permission to write: ${e}`);
            if (-21 === t.errno || -4068 === t.errno) throw new Di(`Is a directory: ${e}`);
            throw t;
        }
    });
}
function qi(e) {
    return t(this, void 0, void 0, function*() {
        if (!(yield Ni.accessAsync(e))) return yield Ni.mkdirAsync(e, {
            recursive: !0,
            mode: 493
        }), !0;
        if (!(yield Ni.statAsync(e)).isDirectory()) throw new Di(`Not a directory: ${e}`);
        return !1;
    });
}
function Ki(e, i, r, n) {
    return t(this, void 0, void 0, function*() {
        if (!r) return function(e, i, r) {
            return t(this, void 0, void 0, function*() {
                const t = r ? i : yield Hi(e, i), n = Pi.join(e, t), s = yield Wi(n);
                return new ji(n, i, t, s);
            });
        }(e.path, i, n);
        const s = JSON.parse(i);
        if (!s.hasOwnProperty("path_name") || !s.hasOwnProperty("path_id") || !s.hasOwnProperty("is_dir") || s.path_name.length < 1) throw new Di(`Invalid name: ${i}`);
        let a, o;
        if (i = s.path_name[s.path_name.length - 1], n ? a = s.path_name[0] : e.maps.has(s.path_id) ? a = e.maps.get(s.path_id) : (a = yield Hi(e.path, s.path_name[0]), e.maps.set(s.path_id, a)), s.path_name.length > 1) {
            const t = Pi.join(e.path, a, ...s.path_name.slice(1, s.path_name.length - 1));
            yield qi(t), o = Pi.join(t, i);
        } else o = Pi.join(e.path, a);
        if (!0 === s.is_dir) {
            let t = "";
            return (yield qi(o)) && (t = o), new ji(t, i, a, null, !0);
        }
        const l = yield Wi(o);
        return new ji(o, i, a, l);
    });
}
class Ji {
    constructor(t, e, i, r){
        this.closed = !1, this.pos = 0, this.pathId = t, this.relPath = e, this.file = i, this.dir = r;
    }
    getPathId() {
        return this.pathId;
    }
    getRelPath() {
        return this.relPath;
    }
    isDir() {
        return this.dir;
    }
    getSize() {
        return this.file.size;
    }
    readFile(e) {
        return t(this, void 0, void 0, function*() {
            if (this.pos >= this.file.size) return new Uint8Array(0);
            try {
                const t = Math.min(e.byteLength, this.file.size - this.pos), i = this.file.slice(this.pos, this.pos + t);
                return this.pos += t, new Uint8Array((yield i.arrayBuffer()));
            } catch (t) {
                if ("NotReadableError" === t.name) throw new Di(`No permission to read: ${this.relPath.join("/")}`);
                throw new Di(`Read ${this.relPath.join("/")} error: ${t.toString()}`);
            }
        });
    }
    closeFile() {
        this.closed || (this.file = null, this.closed = !0);
    }
}
function Gi(e, r, n, s) {
    var a, o, l, h;
    return t(this, void 0, void 0, function*() {
        if ("file" === r.kind) {
            const t = yield r.getFile();
            n.push(new Ji(e, s, t, !1));
        } else if ("directory" === r.kind) {
            n.push(new Ji(e, s, null, !0));
            const f = r;
            try {
                for(var t, d = !0, u = i(f.values()); t = yield u.next(), !(a = t.done); d = !0){
                    h = t.value, d = !1;
                    const i = h, r = i.name;
                    "file" === i.kind ? yield Gi(e, (yield f.getFileHandle(r)), n, [
                        ...s,
                        r
                    ]) : "directory" === i.kind && (yield Gi(e, (yield f.getDirectoryHandle(r)), n, [
                        ...s,
                        r
                    ]));
                }
            } catch (t) {
                o = {
                    error: t
                };
            } finally{
                try {
                    d || a || !(l = u.return) || (yield l.call(u));
                } finally{
                    if (o) throw o.error;
                }
            }
        }
    });
}
function Xi() {
    return "https:" === window.location.protocol || [
        "localhost",
        "127.0.0.1",
        "[::1]"
    ].includes(window.location.hostname) ? new Di("The browser doesn't support the File System Access API") : new Di("The File System Access API requires HTTPS except localhost");
}
function Yi() {
    return t(this, void 0, void 0, function*() {
        if ("function" != typeof window.showDirectoryPicker) throw Xi();
        let t;
        try {
            t = yield window.showDirectoryPicker({
                id: "trzsz_upload",
                startIn: "documents"
            });
        } catch (t) {
            if ("AbortError" === t.name) return;
            throw t;
        }
        const e = [];
        return yield Gi(0, t, e, [
            t.name
        ]), e;
    });
}
class Qi {
    constructor(t, e, i, r = !1){
        this.closed = !1, this.fileName = t, this.localName = e, this.writer = i, this.dir = r;
    }
    getFileName() {
        return this.fileName;
    }
    getLocalName() {
        return this.localName;
    }
    isDir() {
        return this.dir;
    }
    writeFile(e) {
        return t(this, void 0, void 0, function*() {
            yield this.writer.write(e);
        });
    }
    closeFile() {
        this.closed || (this.writer.close(), this.writer = null, this.closed = !0);
    }
    deleteFile() {
        return t(this, void 0, void 0, function*() {
            return "";
        });
    }
}
function Vi(e, r) {
    var n, s, a, o;
    return t(this, void 0, void 0, function*() {
        const t = new Set;
        try {
            for(var l, h = !0, d = i(e.values()); l = yield d.next(), !(n = l.done); h = !0){
                o = l.value, h = !1;
                const e = o;
                t.add(e.name);
            }
        } catch (t) {
            s = {
                error: t
            };
        } finally{
            try {
                h || n || !(a = d.return) || (yield a.call(d));
            } finally{
                if (s) throw s.error;
            }
        }
        if (!t.has(r)) return r;
        for(let e = 0; e < 1e3; e++){
            const i = `${r}.${e}`;
            if (!t.has(i)) return i;
        }
    });
}
function tr(e, i) {
    return t(this, void 0, void 0, function*() {
        try {
            const t = yield e.getFileHandle(i[i.length - 1], {
                create: !0
            });
            return yield t.createWritable();
        } catch (t) {
            if ("NoModificationAllowedError" === t.name) throw new Di(`No permission to write: ${i.join("/")}`);
            if ("TypeMismatchError" === t.name) throw new Di(`Is a directory: ${i.join("/")}`);
            throw new Di(`Write ${i.join("/")} error: ${t.toString()}`);
        }
    });
}
function er(e, i) {
    return t(this, void 0, void 0, function*() {
        try {
            return yield e.getDirectoryHandle(i[i.length - 1], {
                create: !0
            });
        } catch (t) {
            if ("InvalidStateError" === t.name) throw new Di(`No permission to create: ${i.join("/")}`);
            if ("TypeMismatchError" === t.name) throw new Di(`Not a directory: ${i.join("/")}`);
            throw new Di(`Create ${i.join("/")} error: ${t.toString()}`);
        }
    });
}
function ir(e, i, r, n) {
    return t(this, void 0, void 0, function*() {
        const s = e.handle;
        if (!r) return yield function(e, i, r) {
            return t(this, void 0, void 0, function*() {
                const t = r ? i : yield Vi(e, i), n = yield tr(e, [
                    e.name,
                    t
                ]);
                return new Qi(i, t, n);
            });
        }(s, i, n);
        const a = JSON.parse(i);
        if (!a.hasOwnProperty("path_name") || !a.hasOwnProperty("path_id") || !a.hasOwnProperty("is_dir") || a.path_name.length < 1) throw new Di(`Invalid name: ${i}`);
        let o;
        i = a.path_name[a.path_name.length - 1], n ? o = a.path_name[0] : e.maps.has(a.path_id) ? o = e.maps.get(a.path_id) : (o = yield Vi(s, a.path_name[0]), e.maps.set(a.path_id, o));
        let l = s;
        const h = [
            s.name,
            o
        ];
        if (a.path_name.length > 1) {
            l = yield er(l, h);
            for(let t = 1; t < a.path_name.length - 1; t++)h.push(a.path_name[t]), l = yield er(l, h);
            h.push(i);
        }
        if (!0 === a.is_dir) return yield er(l, h), new Qi(i, o, null, !0);
        const d = yield a.readAsBuffer(), u = new Blob([
            d
        ], {
            type: "application/octet-stream"
        }), f = document.createElement("a");
        f.href = URL.createObjectURL(u), f.download = a.name, document.body.appendChild(f), f.click(), document.body.removeChild(f);
        const c = yield tr(l, h);
        return new Qi(i, o, c);
    });
}
class rr {
    constructor(){
        this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashStr(t, e = !1) {
        return this.onePassHasher.start().appendStr(t).end(e);
    }
    static hashAsciiStr(t, e = !1) {
        return this.onePassHasher.start().appendAsciiStr(t).end(e);
    }
    static _hex(t) {
        const e = rr.hexChars, i = rr.hexOut;
        let r, n, s, a;
        for(a = 0; a < 4; a += 1)for(n = 8 * a, r = t[a], s = 0; s < 8; s += 2)i[n + 1 + s] = e.charAt(15 & r), r >>>= 4, i[n + 0 + s] = e.charAt(15 & r), r >>>= 4;
        return i.join("");
    }
    static _md5cycle(t, e) {
        let i = t[0], r = t[1], n = t[2], s = t[3];
        i += (r & n | ~r & s) + e[0] - 680876936 | 0, i = (i << 7 | i >>> 25) + r | 0, s += (i & r | ~i & n) + e[1] - 389564586 | 0, s = (s << 12 | s >>> 20) + i | 0, n += (s & i | ~s & r) + e[2] + 606105819 | 0, n = (n << 17 | n >>> 15) + s | 0, r += (n & s | ~n & i) + e[3] - 1044525330 | 0, r = (r << 22 | r >>> 10) + n | 0, i += (r & n | ~r & s) + e[4] - 176418897 | 0, i = (i << 7 | i >>> 25) + r | 0, s += (i & r | ~i & n) + e[5] + 1200080426 | 0, s = (s << 12 | s >>> 20) + i | 0, n += (s & i | ~s & r) + e[6] - 1473231341 | 0, n = (n << 17 | n >>> 15) + s | 0, r += (n & s | ~n & i) + e[7] - 45705983 | 0, r = (r << 22 | r >>> 10) + n | 0, i += (r & n | ~r & s) + e[8] + 1770035416 | 0, i = (i << 7 | i >>> 25) + r | 0, s += (i & r | ~i & n) + e[9] - 1958414417 | 0, s = (s << 12 | s >>> 20) + i | 0, n += (s & i | ~s & r) + e[10] - 42063 | 0, n = (n << 17 | n >>> 15) + s | 0, r += (n & s | ~n & i) + e[11] - 1990404162 | 0, r = (r << 22 | r >>> 10) + n | 0, i += (r & n | ~r & s) + e[12] + 1804603682 | 0, i = (i << 7 | i >>> 25) + r | 0, s += (i & r | ~i & n) + e[13] - 40341101 | 0, s = (s << 12 | s >>> 20) + i | 0, n += (s & i | ~s & r) + e[14] - 1502002290 | 0, n = (n << 17 | n >>> 15) + s | 0, r += (n & s | ~n & i) + e[15] + 1236535329 | 0, r = (r << 22 | r >>> 10) + n | 0, i += (r & s | n & ~s) + e[1] - 165796510 | 0, i = (i << 5 | i >>> 27) + r | 0, s += (i & n | r & ~n) + e[6] - 1069501632 | 0, s = (s << 9 | s >>> 23) + i | 0, n += (s & r | i & ~r) + e[11] + 643717713 | 0, n = (n << 14 | n >>> 18) + s | 0, r += (n & i | s & ~i) + e[0] - 373897302 | 0, r = (r << 20 | r >>> 12) + n | 0, i += (r & s | n & ~s) + e[5] - 701558691 | 0, i = (i << 5 | i >>> 27) + r | 0, s += (i & n | r & ~n) + e[10] + 38016083 | 0, s = (s << 9 | s >>> 23) + i | 0, n += (s & r | i & ~r) + e[15] - 660478335 | 0, n = (n << 14 | n >>> 18) + s | 0, r += (n & i | s & ~i) + e[4] - 405537848 | 0, r = (r << 20 | r >>> 12) + n | 0, i += (r & s | n & ~s) + e[9] + 568446438 | 0, i = (i << 5 | i >>> 27) + r | 0, s += (i & n | r & ~n) + e[14] - 1019803690 | 0, s = (s << 9 | s >>> 23) + i | 0, n += (s & r | i & ~r) + e[3] - 187363961 | 0, n = (n << 14 | n >>> 18) + s | 0, r += (n & i | s & ~i) + e[8] + 1163531501 | 0, r = (r << 20 | r >>> 12) + n | 0, i += (r & s | n & ~s) + e[13] - 1444681467 | 0, i = (i << 5 | i >>> 27) + r | 0, s += (i & n | r & ~n) + e[2] - 51403784 | 0, s = (s << 9 | s >>> 23) + i | 0, n += (s & r | i & ~r) + e[7] + 1735328473 | 0, n = (n << 14 | n >>> 18) + s | 0, r += (n & i | s & ~i) + e[12] - 1926607734 | 0, r = (r << 20 | r >>> 12) + n | 0, i += (r ^ n ^ s) + e[5] - 378558 | 0, i = (i << 4 | i >>> 28) + r | 0, s += (i ^ r ^ n) + e[8] - 2022574463 | 0, s = (s << 11 | s >>> 21) + i | 0, n += (s ^ i ^ r) + e[11] + 1839030562 | 0, n = (n << 16 | n >>> 16) + s | 0, r += (n ^ s ^ i) + e[14] - 35309556 | 0, r = (r << 23 | r >>> 9) + n | 0, i += (r ^ n ^ s) + e[1] - 1530992060 | 0, i = (i << 4 | i >>> 28) + r | 0, s += (i ^ r ^ n) + e[4] + 1272893353 | 0, s = (s << 11 | s >>> 21) + i | 0, n += (s ^ i ^ r) + e[7] - 155497632 | 0, n = (n << 16 | n >>> 16) + s | 0, r += (n ^ s ^ i) + e[10] - 1094730640 | 0, r = (r << 23 | r >>> 9) + n | 0, i += (r ^ n ^ s) + e[13] + 681279174 | 0, i = (i << 4 | i >>> 28) + r | 0, s += (i ^ r ^ n) + e[0] - 358537222 | 0, s = (s << 11 | s >>> 21) + i | 0, n += (s ^ i ^ r) + e[3] - 722521979 | 0, n = (n << 16 | n >>> 16) + s | 0, r += (n ^ s ^ i) + e[6] + 76029189 | 0, r = (r << 23 | r >>> 9) + n | 0, i += (r ^ n ^ s) + e[9] - 640364487 | 0, i = (i << 4 | i >>> 28) + r | 0, s += (i ^ r ^ n) + e[12] - 421815835 | 0, s = (s << 11 | s >>> 21) + i | 0, n += (s ^ i ^ r) + e[15] + 530742520 | 0, n = (n << 16 | n >>> 16) + s | 0, r += (n ^ s ^ i) + e[2] - 995338651 | 0, r = (r << 23 | r >>> 9) + n | 0, i += (n ^ (r | ~s)) + e[0] - 198630844 | 0, i = (i << 6 | i >>> 26) + r | 0, s += (r ^ (i | ~n)) + e[7] + 1126891415 | 0, s = (s << 10 | s >>> 22) + i | 0, n += (i ^ (s | ~r)) + e[14] - 1416354905 | 0, n = (n << 15 | n >>> 17) + s | 0, r += (s ^ (n | ~i)) + e[5] - 57434055 | 0, r = (r << 21 | r >>> 11) + n | 0, i += (n ^ (r | ~s)) + e[12] + 1700485571 | 0, i = (i << 6 | i >>> 26) + r | 0, s += (r ^ (i | ~n)) + e[3] - 1894986606 | 0, s = (s << 10 | s >>> 22) + i | 0, n += (i ^ (s | ~r)) + e[10] - 1051523 | 0, n = (n << 15 | n >>> 17) + s | 0, r += (s ^ (n | ~i)) + e[1] - 2054922799 | 0, r = (r << 21 | r >>> 11) + n | 0, i += (n ^ (r | ~s)) + e[8] + 1873313359 | 0, i = (i << 6 | i >>> 26) + r | 0, s += (r ^ (i | ~n)) + e[15] - 30611744 | 0, s = (s << 10 | s >>> 22) + i | 0, n += (i ^ (s | ~r)) + e[6] - 1560198380 | 0, n = (n << 15 | n >>> 17) + s | 0, r += (s ^ (n | ~i)) + e[13] + 1309151649 | 0, r = (r << 21 | r >>> 11) + n | 0, i += (n ^ (r | ~s)) + e[4] - 145523070 | 0, i = (i << 6 | i >>> 26) + r | 0, s += (r ^ (i | ~n)) + e[11] - 1120210379 | 0, s = (s << 10 | s >>> 22) + i | 0, n += (i ^ (s | ~r)) + e[2] + 718787259 | 0, n = (n << 15 | n >>> 17) + s | 0, r += (s ^ (n | ~i)) + e[9] - 343485551 | 0, r = (r << 21 | r >>> 11) + n | 0, t[0] = i + t[0] | 0, t[1] = r + t[1] | 0, t[2] = n + t[2] | 0, t[3] = s + t[3] | 0;
    }
    start() {
        return this._dataLength = 0, this._bufferLength = 0, this._state.set(rr.stateIdentity), this;
    }
    appendStr(t) {
        const e = this._buffer8, i = this._buffer32;
        let r, n, s = this._bufferLength;
        for(n = 0; n < t.length; n += 1){
            if (r = t.charCodeAt(n), r < 128) e[s++] = r;
            else if (r < 2048) e[s++] = 192 + (r >>> 6), e[s++] = 63 & r | 128;
            else if (r < 55296 || r > 56319) e[s++] = 224 + (r >>> 12), e[s++] = r >>> 6 & 63 | 128, e[s++] = 63 & r | 128;
            else {
                if (r = 1024 * (r - 55296) + (t.charCodeAt(++n) - 56320) + 65536, r > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF");
                e[s++] = 240 + (r >>> 18), e[s++] = r >>> 12 & 63 | 128, e[s++] = r >>> 6 & 63 | 128, e[s++] = 63 & r | 128;
            }
            s >= 64 && (this._dataLength += 64, rr._md5cycle(this._state, i), s -= 64, i[0] = i[16]);
        }
        return this._bufferLength = s, this;
    }
    appendAsciiStr(t) {
        const e = this._buffer8, i = this._buffer32;
        let r, n = this._bufferLength, s = 0;
        for(;;){
            for(r = Math.min(t.length - s, 64 - n); r--;)e[n++] = t.charCodeAt(s++);
            if (n < 64) break;
            this._dataLength += 64, rr._md5cycle(this._state, i), n = 0;
        }
        return this._bufferLength = n, this;
    }
    appendByteArray(t) {
        const e = this._buffer8, i = this._buffer32;
        let r, n = this._bufferLength, s = 0;
        for(;;){
            for(r = Math.min(t.length - s, 64 - n); r--;)e[n++] = t[s++];
            if (n < 64) break;
            this._dataLength += 64, rr._md5cycle(this._state, i), n = 0;
        }
        return this._bufferLength = n, this;
    }
    getState() {
        const t = this._state;
        return {
            buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
            buflen: this._bufferLength,
            length: this._dataLength,
            state: [
                t[0],
                t[1],
                t[2],
                t[3]
            ]
        };
    }
    setState(t) {
        const e = t.buffer, i = t.state, r = this._state;
        let n;
        for(this._dataLength = t.length, this._bufferLength = t.buflen, r[0] = i[0], r[1] = i[1], r[2] = i[2], r[3] = i[3], n = 0; n < e.length; n += 1)this._buffer8[n] = e.charCodeAt(n);
    }
    end(t = !1) {
        const e = this._bufferLength, i = this._buffer8, r = this._buffer32, n = 1 + (e >> 2);
        this._dataLength += e;
        const s = 8 * this._dataLength;
        if (i[e] = 128, i[e + 1] = i[e + 2] = i[e + 3] = 0, r.set(rr.buffer32Identity.subarray(n), n), e > 55 && (rr._md5cycle(this._state, r), r.set(rr.buffer32Identity)), s <= 4294967295) r[14] = s;
        else {
            const t = s.toString(16).match(/(.*?)(.{0,8})$/);
            if (null === t) return;
            const e = parseInt(t[2], 16), i = parseInt(t[1], 16) || 0;
            r[14] = e, r[15] = i;
        }
        return rr._md5cycle(this._state, r), t ? this._state : rr._hex(this._state);
    }
}
if (rr.stateIdentity = new Int32Array([
    1732584193,
    -271733879,
    -1732584194,
    271733878
]), rr.buffer32Identity = new Int32Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]), rr.hexChars = "0123456789abcdef", rr.hexOut = [], rr.onePassHasher = new rr, "5d41402abc4b2a76b9719d911017c592" !== rr.hashStr("hello")) throw new Error("Md5 self test failed.");
function nr(t) {
    return 97 <= t && t <= 122 || 65 <= t && t <= 90 || 48 <= t && t <= 57 || 35 == t || 58 == t || 43 == t || 47 == t || 61 == t;
}
class sr {
    constructor(){
        this.bufArray = [], this.resolve = null, this.reject = null, this.bufHead = 0, this.bufTail = 0, this.nextIdx = 0, this.nextBuf = null, this.arrBuf = new ArrayBuffer(128);
    }
    addBuffer(t) {
        this.bufArray[this.bufTail++] = t, this.resolve && (this.resolve(), this.resolve = null, this.reject = null);
    }
    stopBuffer() {
        this.reject && (this.reject(new Di("Stopped")), this.reject = null, this.resolve = null);
    }
    drainBuffer() {
        this.bufArray = [], this.bufHead = 0, this.bufTail = 0;
    }
    toUint8Array(e) {
        return t(this, void 0, void 0, function*() {
            if ("string" == typeof e) return Fi(e);
            if (e instanceof ArrayBuffer) return new Uint8Array(e);
            if (e instanceof Uint8Array) return e;
            if (e instanceof Blob) {
                const t = yield e.arrayBuffer();
                return new Uint8Array(t);
            }
            throw new Di("The buffer type is not supported", null, !0);
        });
    }
    nextBuffer() {
        return t(this, void 0, void 0, function*() {
            if (this.nextBuf && this.nextIdx < this.nextBuf.length) return this.nextBuf.subarray(this.nextIdx);
            this.bufHead === this.bufTail && (0 !== this.bufHead && (this.bufHead = 0, this.bufTail = 0), yield new Promise((t, e)=>{
                this.resolve = t, this.reject = e;
            }));
            const t = this.bufArray[this.bufHead];
            return this.bufArray[this.bufHead] = null, this.bufHead++, this.nextBuf = yield this.toUint8Array(t), this.nextIdx = 0, this.nextBuf;
        });
    }
    growBuffer(t, e, i) {
        const r = Math.max(2 * t.length, e + i);
        this.arrBuf = new ArrayBuffer(r);
        const n = new Uint8Array(this.arrBuf);
        return n.set(t.subarray(0, e)), n;
    }
    appendBuffer(t, e, i) {
        const r = t.length >= e + i.length ? t : this.growBuffer(t, e, i.length);
        return r.set(i, e), r;
    }
    readLine() {
        return t(this, void 0, void 0, function*() {
            let t = new Uint8Array(this.arrBuf), e = 0;
            for(;;){
                let i = yield this.nextBuffer();
                const r = i.indexOf(10);
                if (r >= 0 ? (this.nextIdx += r + 1, i = i.subarray(0, r)) : this.nextIdx += i.length, i.includes(3)) throw new Di("Interrupted");
                if (t = this.appendBuffer(t, e, i), e += i.length, r >= 0) return Ii(t.subarray(0, e));
            }
        });
    }
    readBinary(e) {
        return t(this, void 0, void 0, function*() {
            this.arrBuf.byteLength < e && (this.arrBuf = new ArrayBuffer(e));
            const t = new Uint8Array(this.arrBuf, 0, e);
            let i = 0;
            for(; i < e;){
                const r = e - i;
                let n = yield this.nextBuffer();
                n.length > r ? (this.nextIdx += r, n = n.subarray(0, r)) : this.nextIdx += n.length, t.set(n, i), i += n.length;
            }
            return t;
        });
    }
    readLineOnWindows() {
        return t(this, void 0, void 0, function*() {
            let t = new Uint8Array(this.arrBuf), e = 27, i = !1, r = !1, n = !1, s = !1, a = !1, o = 0;
            for(;;){
                let l = yield this.nextBuffer();
                const h = l.indexOf(33);
                h >= 0 ? (this.nextIdx += h + 1, l = l.subarray(0, h)) : this.nextIdx += l.length;
                for(let h = 0; h < l.length; h++){
                    const d = l[h];
                    if (3 == d) throw new Di("Interrupted");
                    if (10 == d && (r = !0), i) Ri(d) && (i = !1, 72 == d && e >= 48 && e <= 57 && (n = !0)), 91 == e && 72 == d && (s = !0), e = d;
                    else if (27 == d) i = !0, e = d;
                    else if (nr(d)) {
                        if (n && (n = !1, r && o > 0 && (d == t[o - 1] || a))) {
                            t[o - 1] = d;
                            continue;
                        }
                        o >= t.length && (t = this.growBuffer(t, o, l.length)), t[o++] = d, a = s, s = !1, r = !1;
                    }
                }
                if (h >= 0 && o > 0 && !i) return Ii(t.subarray(0, o));
            }
        });
    }
}
function ar(t) {
    const e = [];
    for(let i = 0; i < t.length; i++)e.push([
        t[i][0].charCodeAt(0),
        t[i][1].charCodeAt(0),
        t[i][1].charCodeAt(1)
    ]);
    return e;
}
class or {
    constructor(t, e = !1){
        this.buffer = new sr, this.remoteIsWindows = !1, this.lastInputTime = 0, this.openedFiles = [], this.createdFiles = [], this.tmuxOutputJunk = !1, this.cleanTimeoutInMilliseconds = 100, this.transferConfig = {}, this.stopped = !1, this.maxChunkTimeInMilliseconds = 0, this.protocolNewline = "\n", this.writer = t, this.isWindowsShell = e;
    }
    cleanup() {
        for (const t of this.openedFiles)t.closeFile();
    }
    addReceivedData(t) {
        this.stopped || this.buffer.addBuffer(t), this.lastInputTime = Date.now();
    }
    stopTransferring() {
        return t(this, void 0, void 0, function*() {
            this.cleanTimeoutInMilliseconds = Math.max(2 * this.maxChunkTimeInMilliseconds, 500), this.stopped = !0, this.buffer.stopBuffer();
        });
    }
    cleanInput(e) {
        return t(this, void 0, void 0, function*() {
            for(this.stopped = !0, this.buffer.drainBuffer(), this.lastInputTime = Date.now();;){
                const t = e - (Date.now() - this.lastInputTime);
                if (t <= 0) return;
                yield new Promise((e)=>setTimeout(e, t));
            }
        });
    }
    sendLine(e, i) {
        return t(this, void 0, void 0, function*() {
            this.writer(`#${e}:${i}${this.protocolNewline}`);
        });
    }
    recvLine(e, i = !1) {
        return t(this, void 0, void 0, function*() {
            if (this.stopped) throw new Di("Stopped");
            if (this.isWindowsShell || this.remoteIsWindows) {
                let t = yield this.buffer.readLineOnWindows();
                const i = t.lastIndexOf("#" + e + ":");
                if (i >= 0) t = t.substring(i);
                else {
                    const e = t.lastIndexOf("#");
                    e > 0 && (t = t.substring(e));
                }
                return t;
            }
            let t = yield this.buffer.readLine();
            if (this.tmuxOutputJunk || i) {
                if (t.length > 0) for(; "\r" === t[t.length - 1];)t = t.substring(0, t.length - 1) + (yield this.buffer.readLine());
                const i = t.lastIndexOf("#" + e + ":");
                if (i >= 0) t = t.substring(i);
                else {
                    const e = t.lastIndexOf("#");
                    e > 0 && (t = t.substring(e));
                }
                t = function(t) {
                    for(;;){
                        const e = t.indexOf("\x1bP=");
                        if (e < 0) return t;
                        let i = e + 3;
                        const r = t.substring(i).indexOf("\x1bP=");
                        if (r < 0) return t.substring(0, e);
                        i += r + 3;
                        const n = t.substring(i).indexOf("\x1b\\");
                        if (n < 0) return t.substring(0, e);
                        i += n + 2, t = t.substring(0, e) + t.substring(i);
                    }
                }(t);
            }
            return t;
        });
    }
    recvCheck(e, i = !1) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvLine(e, i), r = t.indexOf(":");
            if (r < 1) throw new Di(Ci(t), "colon", !0);
            const n = t.substring(1, r), s = t.substring(r + 1);
            if (n != e) throw new Di(s, n, !0);
            return s;
        });
    }
    sendInteger(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendLine(e, i.toString());
        });
    }
    recvInteger(e, i = !1) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvCheck(e, i);
            return Number(t);
        });
    }
    checkInteger(e) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvInteger("SUCC");
            if (t !== e) throw new Di(`Integer check [${t}] <> [${e}]`, null, !0);
        });
    }
    sendString(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendLine(e, Ci(i));
        });
    }
    recvString(e, i = !1) {
        return t(this, void 0, void 0, function*() {
            return Ii(Bi((yield this.recvCheck(e, i))), "utf8");
        });
    }
    checkString(e) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvString("SUCC");
            if (t !== e) throw new Di(`String check [${t}] <> [${e}]`, null, !0);
        });
    }
    sendBinary(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendLine(e, Ci(i));
        });
    }
    recvBinary(e, i = !1) {
        return t(this, void 0, void 0, function*() {
            return Bi((yield this.recvCheck(e, i)));
        });
    }
    checkBinary(e) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvBinary("SUCC");
            if (t.length != e.length) throw new Di(`Binary length check [${t.length}] <> [${e.length}]`, null, !0);
            for(let i = 0; i < t.length; i++)if (t[i] != e[i]) throw new Di(`Binary check [${t[i]}] <> [${e[i]}]`, null, !0);
        });
    }
    sendData(e, i, r) {
        return t(this, void 0, void 0, function*() {
            if (!i) return void (yield this.sendBinary("DATA", e));
            const t = function(t, e) {
                if (!e.length) return t;
                const i = new Uint8Array(2 * t.length);
                let r = 0;
                for(let n = 0; n < t.length; n++){
                    let s = -1;
                    for(let i = 0; i < e.length; i++)if (t[n] == e[i][0]) {
                        s = i;
                        break;
                    }
                    s < 0 ? i[r++] = t[n] : (i[r++] = e[s][1], i[r++] = e[s][2]);
                }
                return i.subarray(0, r);
            }(e, r);
            this.writer(`#DATA:${t.length}\n`), this.writer(t);
        });
    }
    recvData(e, i, r) {
        return t(this, void 0, void 0, function*() {
            return yield Promise.race([
                new Promise((t, e)=>setTimeout(()=>{
                        this.cleanTimeoutInMilliseconds = 3e3, e(new Di("Receive data timeout"));
                    }, r)),
                (()=>t(this, void 0, void 0, function*() {
                        if (!e) return yield this.recvBinary("DATA");
                        const t = yield this.recvInteger("DATA");
                        return function(t, e) {
                            if (!e.length) return t;
                            const i = new Uint8Array(t.length);
                            let r = 0;
                            for(let n = 0; n < t.length; n++){
                                let s = -1;
                                if (n < t.length - 1) {
                                    for(let i = 0; i < e.length; i++)if (t[n] == e[i][1] && t[n + 1] == e[i][2]) {
                                        s = i;
                                        break;
                                    }
                                }
                                s < 0 ? i[r++] = t[n] : (i[r++] = e[s][0], n++);
                            }
                            return i.subarray(0, r);
                        }((yield this.buffer.readBinary(t)), i);
                    }))()
            ]);
        });
    }
    sendAction(e, i) {
        return t(this, void 0, void 0, function*() {
            const t = {
                lang: "js",
                confirm: e,
                version: "1.1.5",
                support_dir: !0
            };
            (this.isWindowsShell || i) && (t.binary = !1, t.newline = "!\n"), i && (this.remoteIsWindows = !0, this.protocolNewline = "!\n"), yield this.sendString("ACT", JSON.stringify(t));
        });
    }
    recvAction() {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvString("ACT", !0), e = JSON.parse(t);
            return e.newline && (this.protocolNewline = e.newline), e;
        });
    }
    sendConfig(e, i, r, n) {
        return t(this, void 0, void 0, function*() {
            const t = {
                lang: "js"
            };
            e.quiet && (t.quiet = !0), e.binary && (t.binary = !0, t.escape_chars = i), e.directory && (t.directory = !0), e.bufsize && (t.bufsize = e.bufsize), e.timeout && (t.timeout = e.timeout), e.overwrite && (t.overwrite = !0), r == Ui && (t.tmux_output_junk = !0), n > 0 && (t.tmux_pane_width = n);
            let s = JSON.stringify(t);
            s = s.replace(/[\u007F-\uFFFF]/g, function(t) {
                return "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
            }), this.transferConfig = t, yield this.sendString("CFG", s);
        });
    }
    recvConfig() {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvString("CFG", !0);
            return this.transferConfig = JSON.parse(t), this.tmuxOutputJunk = !0 === this.transferConfig.tmux_output_junk, this.transferConfig;
        });
    }
    clientExit(e) {
        return t(this, void 0, void 0, function*() {
            yield this.sendString("EXIT", e);
        });
    }
    recvExit() {
        return t(this, void 0, void 0, function*() {
            return this.recvString("EXIT");
        });
    }
    serverExit(e) {
        return t(this, void 0, void 0, function*() {
            yield this.cleanInput(500), yield function() {
                return t(this, void 0, void 0, function*() {});
            }(), this.isWindowsShell ? (e = e.replace(/\n/g, "\r\n"), process.stdout.write("\x1b[H\x1b[2J\x1b[?1049l")) : process.stdout.write("\x1b8\x1b[0J"), process.stdout.write(e), process.stdout.write("\r\n"), process.stdout.write("\x1b[?25h"), this.transferConfig.tmux_output_junk && (yield function() {
                return t(this, void 0, void 0, function*() {
                    const t = require("4dc1848a8a3dce6f").promisify(require("9c751e0005e83403").exec);
                    yield t("tmux refresh-client");
                });
            }());
        });
    }
    deleteCreatedFiles() {
        return t(this, void 0, void 0, function*() {
            const t = [];
            for (const e of this.createdFiles){
                const i = yield e.deleteFile();
                i && t.push(i);
            }
            return t;
        });
    }
    clientError(e) {
        return t(this, void 0, void 0, function*() {
            yield this.cleanInput(this.cleanTimeoutInMilliseconds);
            const t = Di.getErrorMessage(e);
            let i = !0;
            if (e instanceof Di) {
                if (i = e.isTraceBack(), e.isRemoteExit()) return;
                if (e.isRemoteFail()) return void (i && console.log(t));
            }
            yield this.sendString(i ? "FAIL" : "fail", t), i && console.log(t);
        });
    }
    serverError(e) {
        return t(this, void 0, void 0, function*() {
            yield this.cleanInput(this.cleanTimeoutInMilliseconds);
            const t = Di.getErrorMessage(e);
            let i = !0;
            if (e instanceof Di) {
                if (e.isStopAndDelete()) {
                    const t = yield this.deleteCreatedFiles();
                    if (t && t.length) return void (yield this.serverExit([
                        e.message + ":"
                    ].concat(t).join("\r\n- ")));
                }
                if (i = e.isTraceBack(), e.isRemoteExit() || e.isRemoteFail()) return void (yield this.serverExit(t));
            }
            yield this.sendString(i ? "FAIL" : "fail", t), yield this.serverExit(t);
        });
    }
    sendFileNum(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendInteger("NUM", e), yield this.checkInteger(e), i && i.onNum(e);
        });
    }
    sendFileName(e, i, r) {
        return t(this, void 0, void 0, function*() {
            const t = e.getRelPath(), n = t[t.length - 1];
            if (i) {
                const i = {
                    path_id: e.getPathId(),
                    path_name: t,
                    is_dir: e.isDir()
                };
                yield this.sendString("NAME", JSON.stringify(i));
            } else yield this.sendString("NAME", n);
            const s = yield this.recvString("SUCC");
            return r && r.onName(n), s;
        });
    }
    sendFileSize(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendInteger("SIZE", e), yield this.checkInteger(e), i && i.onSize(e);
        });
    }
    sendFileData(e, i, r, n, s, a) {
        return t(this, void 0, void 0, function*() {
            let t = 0;
            a && a.onStep(t);
            let o = 1024, l = new ArrayBuffer(o);
            const h = new rr;
            for(; t < i;){
                const i = Date.now(), d = yield e.readFile(l);
                yield this.sendData(d, r, n), h.appendByteArray(d), yield this.checkInteger(d.length), t += d.length, a && a.onStep(t);
                const u = Date.now() - i;
                d.length == o && u < 500 && o < s ? (o = Math.min(2 * o, s), l = new ArrayBuffer(o)) : u >= 2e3 && o > 1024 && (o = 1024, l = new ArrayBuffer(o)), u > this.maxChunkTimeInMilliseconds && (this.maxChunkTimeInMilliseconds = u);
            }
            return new Uint8Array(h.end(!0).buffer);
        });
    }
    sendFileMD5(e, i) {
        return t(this, void 0, void 0, function*() {
            yield this.sendBinary("MD5", e), yield this.checkBinary(e), i && i.onDone();
        });
    }
    sendFiles(e, i) {
        return t(this, void 0, void 0, function*() {
            this.openedFiles.push(...e);
            const t = !0 === this.transferConfig.binary, r = !0 === this.transferConfig.directory, n = this.transferConfig.bufsize || 10485760, s = this.transferConfig.escape_chars ? ar(this.transferConfig.escape_chars) : [];
            yield this.sendFileNum(e.length, i);
            const a = [];
            for (const o of e){
                const e = yield this.sendFileName(o, r, i);
                if (a.includes(e) || a.push(e), o.isDir()) continue;
                const l = o.getSize();
                yield this.sendFileSize(l, i);
                const h = yield this.sendFileData(o, l, t, s, n, i);
                o.closeFile(), yield this.sendFileMD5(h, i);
            }
            return a;
        });
    }
    recvFileNum(e) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvInteger("NUM");
            return yield this.sendInteger("SUCC", t), e && e.onNum(t), t;
        });
    }
    recvFileName(e, i, r, n, s) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvString("NAME"), a = yield i(e, t, r, n);
            return this.createdFiles.push(a), yield this.sendString("SUCC", a.getLocalName()), s && s.onName(a.getFileName()), a;
        });
    }
    recvFileSize(e) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvInteger("SIZE");
            return yield this.sendInteger("SUCC", t), e && e.onSize(t), t;
        });
    }
    recvFileData(e, i, r, n, s, a) {
        return t(this, void 0, void 0, function*() {
            let t = 0;
            a && a.onStep(t);
            const o = new rr;
            for(; t < i;){
                const i = Date.now(), l = yield this.recvData(r, n, s);
                yield e.writeFile(l), t += l.length, a && a.onStep(t), yield this.sendInteger("SUCC", l.length), o.appendByteArray(l);
                const h = Date.now() - i;
                h > this.maxChunkTimeInMilliseconds && (this.maxChunkTimeInMilliseconds = h);
            }
            return new Uint8Array(o.end(!0).buffer);
        });
    }
    recvFileMD5(e, i) {
        return t(this, void 0, void 0, function*() {
            const t = yield this.recvBinary("MD5");
            if (e.length != t.length) throw new Di("Check MD5 failed");
            for(let i = 0; i < e.length; i++)if (e[i] != t[i]) throw new Di("Check MD5 failed");
            yield this.sendBinary("SUCC", e), i && i.onDone();
        });
    }
    recvFiles(e, i, r) {
        return t(this, void 0, void 0, function*() {
            const t = !0 === this.transferConfig.binary, n = !0 === this.transferConfig.directory, s = !0 === this.transferConfig.overwrite, a = this.transferConfig.timeout ? 1e3 * this.transferConfig.timeout : 1e5, o = this.transferConfig.escape_chars ? ar(this.transferConfig.escape_chars) : [], l = yield this.recvFileNum(r), h = [];
            for(let d = 0; d < l; d++){
                const l = yield this.recvFileName(e, i, n, s, r);
                if (h.includes(l.getLocalName()) || h.push(l.getLocalName()), l.isDir()) continue;
                this.openedFiles.push(l);
                const d = yield this.recvFileSize(r), u = yield this.recvFileData(l, d, t, o, a, r);
                l.closeFile(), yield this.recvFileMD5(u, r);
            }
            return h;
        });
    }
}
function lr(t, e) {
    e -= 3;
    let i = 0, r = "";
    for(let n = 0; n < t.length; n++){
        if (t.charCodeAt(n) >= 19968 && t.charCodeAt(n) <= 40869) {
            if (i + 2 > e) return {
                sub: r + "...",
                len: i + 3
            };
            i += 2;
        } else {
            if (i + 1 > e) return {
                sub: r + "...",
                len: i + 3
            };
            i += 1;
        }
        r += t[n];
    }
    return {
        sub: r + "...",
        len: i + 3
    };
}
function hr(t) {
    let e = "B";
    do {
        if (t < 1024) break;
        if (e = "KB", (t /= 1024) < 1024) break;
        if (e = "MB", (t /= 1024) < 1024) break;
        if (e = "GB", (t /= 1024) < 1024) break;
        t /= 1024, e = "TB";
    }while (0);
    return t >= 100 ? `${t.toFixed(0)} ${e}` : t >= 10 ? `${t.toFixed(1)} ${e}` : `${t.toFixed(2)} ${e}`;
}
class dr {
    constructor(t, e, i){
        this.lastUpdateTime = 0, this.firstWrite = !0, this.speedCnt = 0, this.speedIdx = 0, this.timeArray = new Array(30), this.stepArray = new Array(30), this.writer = t, this.tmuxPaneColumns = i || 0, this.columns = this.tmuxPaneColumns > 1 ? this.tmuxPaneColumns - 1 : e;
    }
    setTerminalColumns(t) {
        this.columns = t, this.tmuxPaneColumns > 0 && (this.tmuxPaneColumns = 0);
    }
    onNum(t) {
        this.fileCount = t, this.fileIdx = 0;
    }
    onName(t) {
        this.fileName = t, this.fileIdx += 1, this.startTime = Date.now(), this.timeArray[0] = this.startTime, this.stepArray[0] = 0, this.speedCnt = 1, this.speedIdx = 1, this.fileStep = -1;
    }
    onSize(t) {
        this.fileSize = t;
    }
    onStep(t) {
        t <= this.fileStep || (this.fileStep = t, this.showProgress());
    }
    hideCursor() {
        this.writer("\x1b[?25l");
    }
    showCursor() {
        this.writer("\x1b[?25h");
    }
    showProgress() {
        const t = Date.now();
        if (t - this.lastUpdateTime < 200) return;
        this.lastUpdateTime = t;
        let e = "100%";
        0 != this.fileSize && (e = Math.round(100 * this.fileStep / this.fileSize).toString() + "%");
        const i = hr(this.fileStep), r = this.getSpeed(t);
        let n = "--- B/s", s = "--- ETA";
        r > 0 && (n = hr(r) + "/s", s = function(t) {
            let e = "";
            t >= 3600 && (e += Math.floor(t / 3600).toString() + ":", t %= 3600);
            const i = Math.floor(t / 60);
            e += i >= 10 ? i.toString() : "0" + i.toString(), e += ":";
            const r = Math.round(t % 60);
            return e += r >= 10 ? r.toString() : "0" + r.toString(), e;
        }(Math.round((this.fileSize - this.fileStep) / r)) + " ETA");
        const a = this.getProgressText(e, i, n, s);
        if (this.firstWrite) return this.firstWrite = !1, void this.writer(a);
        this.tmuxPaneColumns > 0 ? this.writer(`[${this.columns}D${a}`) : this.writer(`\r${a}`);
    }
    getSpeed(t) {
        let e;
        return this.speedCnt <= 30 ? (this.speedCnt++, e = 1e3 * (this.fileStep - this.stepArray[0]) / (t - this.timeArray[0])) : e = 1e3 * (this.fileStep - this.stepArray[this.speedIdx]) / (t - this.timeArray[this.speedIdx]), this.timeArray[this.speedIdx] = t, this.stepArray[this.speedIdx] = this.fileStep, this.speedIdx++, this.speedIdx >= 30 && (this.speedIdx %= 30), isFinite(e) ? e : -1;
    }
    getProgressText(t, e, i, r) {
        const n = 24;
        let s = this.fileCount > 1 ? `(${this.fileIdx}/${this.fileCount}) ${this.fileName}` : this.fileName, a = s.replace(/[\u4e00-\u9fa5]/g, "**").length;
        let o = ` ${t} | ${e} | ${i} | ${r}`;
        do {
            if (this.columns - a - o.length >= n) break;
            if (a > 50 && ({ sub: s, len: a } = lr(s, 50)), this.columns - a - o.length >= n) break;
            if (a > 40 && ({ sub: s, len: a } = lr(s, 40)), this.columns - a - o.length >= n) break;
            if (o = ` ${t} | ${i} | ${r}`, this.columns - a - o.length >= n) break;
            if (a > 30 && ({ sub: s, len: a } = lr(s, 30)), this.columns - a - o.length >= n) break;
            if (o = ` ${t} | ${r}`, this.columns - a - o.length >= n) break;
            if (o = ` ${t}`, this.columns - a - o.length >= n) break;
            if (a > 20 && ({ sub: s, len: a } = lr(s, 20)), this.columns - a - o.length >= n) break;
            s = "", a = 0;
        }while (0);
        let l = this.columns - o.length;
        a > 0 && (l -= a + 1, s += " ");
        return (s + this.getProgressBar(l) + o).trim();
    }
    getProgressBar(t) {
        if (t < 12) return "";
        const e = t - 2;
        let i = e;
        return 0 != this.fileSize && (i = Math.round(e * this.fileStep / this.fileSize)), "[\x1b[36m" + "\u2588".repeat(i) + "\u2591".repeat(e - i) + "\x1b[0m]";
    }
    onDone() {
        0 != this.fileSize && (this.fileStep = this.fileSize, this.lastUpdateTime = 0, this.showProgress());
    }
}
function ur(e, i, r, n) {
    return t(this, void 0, void 0, function*() {
        i.isFile ? yield new Promise((t)=>{
            i.file((i)=>{
                r.push(new Ji(e, n, i, !1)), t();
            });
        }) : i.isDirectory && (r.push(new Ji(e, n, null, !0)), yield new Promise((s)=>{
            i.createReader().readEntries((i)=>t(this, void 0, void 0, function*() {
                    for (const t of i)yield ur(e, t, r, [
                        ...n,
                        t.name
                    ]);
                    s();
                }));
        }));
    });
}
const fr = "::TRZSZ:TRANSFER:", cr = new RegExp(/::TRZSZ:TRANSFER:([SRD]):(\d+\.\d+\.\d+)(:\d+)?/), _r = new Float64Array(Fi(fr).buffer, 0, 2);
class wr {
    constructor(t){
        if (this.trzszTransfer = null, this.textProgressBar = null, this.uniqueIdMaps = new Map, this.uploadFilesList = null, this.uploadFilesResolve = null, this.uploadFilesReject = null, this.uploadInterrupting = !1, this.uploadSkipTrzCommand = !1, !t) throw new Di("TrzszOptions is required");
        if (!t.writeToTerminal) throw new Di("TrzszOptions.writeToTerminal is required");
        if (this.writeToTerminal = t.writeToTerminal, !t.sendToServer) throw new Di("TrzszOptions.sendToServer is required");
        if (this.sendToServer = t.sendToServer, !Ti && !t.chooseSendFiles) throw new Di("TrzszOptions.chooseSendFiles is required when having a node runtime environment");
        if (this.chooseSendFiles = t.chooseSendFiles, !Ti && !t.chooseSaveDirectory) throw new Di("TrzszOptions.chooseSaveDirectory is required when having a node runtime environment");
        this.chooseSaveDirectory = t.chooseSaveDirectory, this.terminalColumns = t.terminalColumns || 80, this.isWindowsShell = !!t.isWindowsShell, this.dragInitTimeout = t.dragInitTimeout || 3e3;
    }
    processServerOutput(t) {
        if (this.isTransferringFiles()) this.trzszTransfer.addReceivedData(t);
        else if (!this.uploadInterrupting) {
            if (this.uploadSkipTrzCommand) {
                this.uploadSkipTrzCommand = !1;
                const e = function(t) {
                    let e;
                    if ("string" == typeof t) e = Fi(t);
                    else if (t instanceof ArrayBuffer) e = new Uint8Array(t);
                    else {
                        if (!(t instanceof Uint8Array)) return t;
                        e = t;
                    }
                    const i = new Uint8Array(e.length);
                    let r = !1, n = 0;
                    for(let t = 0; t < e.length; t++){
                        const s = e[t];
                        r ? Ri(s) && (r = !1) : 27 == s ? r = !0 : i[n++] = s;
                    }
                    for(; n > 0;){
                        const t = i[n - 1];
                        if (13 != t && 10 != t) break;
                        n--;
                    }
                    const s = i.subarray(0, n);
                    return s.length > 100 ? t : String.fromCharCode.apply(null, s);
                }(t);
                if ("trz" === e || "trz -d" === e) return void this.writeToTerminal("\r\n");
            }
            setTimeout(()=>this.detectAndHandleTrzsz(t), 10), this.writeToTerminal(t);
        }
    }
    processTerminalInput(t) {
        this.isTransferringFiles() ? "\x03" === t && this.stopTransferringFiles() : this.sendToServer(t);
    }
    processBinaryInput(t) {
        this.isTransferringFiles() || this.sendToServer(Fi(t));
    }
    setTerminalColumns(t) {
        this.terminalColumns = t, null != this.textProgressBar && this.textProgressBar.setTerminalColumns(t);
    }
    isTransferringFiles() {
        return null != this.trzszTransfer;
    }
    stopTransferringFiles() {
        this.isTransferringFiles() && this.trzszTransfer.stopTransferring();
    }
    uploadFiles(e) {
        return t(this, void 0, void 0, function*() {
            if (this.uploadFilesList || this.isTransferringFiles()) throw new Error("The previous upload has not been completed yet");
            if (e instanceof DataTransferItemList || e instanceof FileList) this.uploadFilesList = yield function(e) {
                return t(this, void 0, void 0, function*() {
                    const t = [], i = [];
                    if (e instanceof FileList) for (const t of e)i.push({
                        isFile: !0,
                        isDirectory: !1,
                        name: t.name,
                        fullPath: "/" + t.name,
                        file: (e)=>e(t)
                    });
                    else for (const t of e){
                        const e = t.webkitGetAsEntry();
                        e && i.push(e);
                    }
                    for(let e = 0; e < i.length; e++){
                        const r = i[e];
                        r && (yield ur(e, r, t, [
                            r.name
                        ]));
                    }
                    return t;
                });
            }(e);
            else {
                if (!function(t, e) {
                    if (!Array.isArray(t)) return !1;
                    for (const i of t)if (typeof i !== e) return !1;
                    return !0;
                }(e, "string") || Ti) throw new Error("The upload items type is not supported");
                this.uploadFilesList = yield $i(e, !0);
            }
            if (!this.uploadFilesList || !this.uploadFilesList.length) throw this.uploadFilesList = null, new Error("No files to upload");
            let i = !1;
            for (const t of this.uploadFilesList)if (t.isDir() || t.getRelPath().length > 1) {
                i = !0;
                break;
            }
            return this.uploadInterrupting = !0, this.sendToServer("\x03"), yield new Promise((t)=>setTimeout(t, 200)), this.uploadInterrupting = !1, this.uploadSkipTrzCommand = !0, this.sendToServer(i ? "trz -d\r" : "trz\r"), setTimeout(()=>{
                this.uploadFilesList && (this.uploadFilesList = null, this.uploadFilesResolve = null, this.uploadFilesReject && (this.uploadFilesReject("Upload does not start"), this.uploadFilesReject = null));
            }, this.dragInitTimeout), new Promise((t, e)=>{
                this.uploadFilesResolve = t, this.uploadFilesReject = e;
            });
        });
    }
    uniqueIdExists(t) {
        if (t.length < 8) return !1;
        if (!this.isWindowsShell && 14 == t.length && t.endsWith("00")) return !1;
        if (this.uniqueIdMaps.has(t)) return !0;
        if (this.uniqueIdMaps.size >= 100) {
            const t = new Map;
            for (const [e, i] of this.uniqueIdMaps)i >= 50 && t.set(e, i - 50);
            this.uniqueIdMaps = t;
        }
        return this.uniqueIdMaps.set(t, this.uniqueIdMaps.size), !1;
    }
    detectAndHandleTrzsz(e) {
        return t(this, void 0, void 0, function*() {
            const i = yield function(e) {
                return t(this, void 0, void 0, function*() {
                    if ("string" == typeof e) {
                        const t = e.lastIndexOf(fr);
                        return t < 0 ? null : e.substring(t);
                    }
                    let t;
                    if (e instanceof ArrayBuffer) t = new Uint8Array(e);
                    else if (e instanceof Uint8Array) t = e;
                    else {
                        if (!(e instanceof Blob)) return null;
                        t = new Uint8Array((yield e.arrayBuffer()));
                    }
                    if (t.length < 26) return null;
                    let i = -1, r = -1;
                    for(;;){
                        if (i = t.indexOf(58, i + 1), i < 0 || t.length - i < 26) return r >= 0 ? Ii(t.subarray(r)) : null;
                        const e = new Float64Array(t.buffer.slice(t.byteOffset + i, t.byteOffset + i + 16));
                        e[0] == _r[0] && e[1] == _r[1] && (r = i, i += 25);
                    }
                });
            }(e);
            if (!i) return;
            const r = i.match(cr);
            if (!r) return;
            const n = r.length > 3 ? r[3] : "";
            if (this.uniqueIdExists(n)) return;
            const s = r[1], a = r[2];
            let o = !1;
            (":1" == n || 14 == n.length && n.endsWith("10")) && (o = !0);
            try {
                this.trzszTransfer = new or(this.sendToServer, this.isWindowsShell), "S" === s ? yield this.handleTrzszDownloadFiles(a, o) : "R" === s ? yield this.handleTrzszUploadFiles(a, !1, o) : "D" === s && (yield this.handleTrzszUploadFiles(a, !0, o)), this.uploadFilesResolve && this.uploadFilesResolve();
            } catch (t) {
                yield this.trzszTransfer.clientError(t), this.uploadFilesReject && this.uploadFilesReject(t);
            } finally{
                this.uploadFilesResolve = null, this.uploadFilesReject = null, this.trzszTransfer.cleanup(), this.textProgressBar && this.textProgressBar.showCursor(), this.textProgressBar = null, this.trzszTransfer = null;
            }
        });
    }
    createProgressBar(t, e) {
        !0 !== t ? (this.textProgressBar = new dr(this.writeToTerminal, this.terminalColumns, e), this.textProgressBar.hideCursor()) : this.textProgressBar = null;
    }
    handleTrzszDownloadFiles(e, i) {
        return t(this, void 0, void 0, function*() {
            let e, r, n;
            if (Ti) {
                const s = yield function() {
                    return t(this, void 0, void 0, function*() {
                        if ("function" != typeof window.showDirectoryPicker) throw Xi();
                        try {
                            return yield window.showDirectoryPicker({
                                id: "trzsz_download",
                                startIn: "downloads",
                                mode: "readwrite"
                            });
                        } catch (t) {
                            if ("AbortError" === t.name) return;
                            throw t;
                        }
                    });
                }();
                if (!s) return void (yield this.trzszTransfer.sendAction(!1, i));
                e = s.name, r = {
                    handle: s,
                    maps: new Map
                }, n = ir;
            } else {
                if (e = yield this.chooseSaveDirectory(), !e) return void (yield this.trzszTransfer.sendAction(!1, i));
                yield function(e) {
                    return t(this, void 0, void 0, function*() {
                        if (!e) return !1;
                        if (!(yield Ni.accessAsync(e))) throw new Di(`No such directory: ${e}`);
                        if (!(yield Ni.statAsync(e)).isDirectory()) throw new Di(`Not a directory: ${e}`);
                        if (!(yield Ni.accessAsync(e, Ni.constants.W_OK))) throw new Di(`No permission to write: ${e}`);
                        return !0;
                    });
                }(e), r = {
                    path: e,
                    maps: new Map
                }, n = Ki;
            }
            yield this.trzszTransfer.sendAction(!0, i);
            const s = yield this.trzszTransfer.recvConfig();
            this.createProgressBar(s.quiet, s.tmux_pane_width);
            const a = yield this.trzszTransfer.recvFiles(r, n, this.textProgressBar);
            yield this.trzszTransfer.clientExit(Li(a, e));
        });
    }
    handleTrzszUploadFiles(e, i, r) {
        return t(this, void 0, void 0, function*() {
            let e;
            if (this.uploadFilesList) e = this.uploadFilesList, this.uploadFilesList = null;
            else if (Ti) e = i ? yield Yi() : yield function() {
                return t(this, void 0, void 0, function*() {
                    if ("function" != typeof window.showOpenFilePicker) throw Xi();
                    let t;
                    try {
                        t = yield window.showOpenFilePicker({
                            id: "trzsz_upload",
                            startIn: "documents",
                            multiple: !0
                        });
                    } catch (t) {
                        if ("AbortError" === t.name) return;
                        throw t;
                    }
                    if (!t || !t.length) return;
                    const e = [];
                    for (const [i, r] of t.entries()){
                        const t = yield r.getFile();
                        e.push(new Ji(i, [
                            t.name
                        ], t, !1));
                    }
                    return e;
                });
            }();
            else {
                const t = yield this.chooseSendFiles(i);
                e = yield $i(t, i);
            }
            if (!e || !e.length) return void (yield this.trzszTransfer.sendAction(!1, r));
            yield this.trzszTransfer.sendAction(!0, r);
            const n = yield this.trzszTransfer.recvConfig();
            !0 === n.overwrite && function(t) {
                const e = new Set;
                for (const i of t){
                    const t = i.getRelPath().join("/");
                    if (e.has(t)) throw new Di(`Duplicate name: ${t}`);
                    e.add(t);
                }
            }(e), this.createProgressBar(n.quiet, n.tmux_pane_width);
            const s = yield this.trzszTransfer.sendFiles(e, this.textProgressBar);
            yield this.trzszTransfer.clientExit(Li(s, ""));
        });
    }
}
class pr {
    constructor(t, e){
        this.disposables = [], this.trzsz = null, this.socket = t, this.options = e || {}, this.socket.binaryType = "arraybuffer";
    }
    activate(t) {
        this.trzsz = new wr({
            writeToTerminal: this.options.writeToTerminal || ((e)=>{
                t.write("string" == typeof e ? e : new Uint8Array(e));
            }),
            sendToServer: this.options.sendToServer || ((t)=>{
                1 === this.socket.readyState && this.socket.send(t);
            }),
            chooseSendFiles: this.options.chooseSendFiles,
            chooseSaveDirectory: this.options.chooseSaveDirectory,
            terminalColumns: t.cols,
            isWindowsShell: this.options.isWindowsShell,
            dragInitTimeout: this.options.dragInitTimeout
        }), this.disposables.push(this.addSocketListener(this.socket, "message", (t)=>this.trzsz.processServerOutput(t.data))), this.disposables.push(t.onData((t)=>this.trzsz.processTerminalInput(t))), this.disposables.push(t.onBinary((t)=>this.trzsz.processBinaryInput(t))), this.disposables.push(t.onResize((t)=>this.trzsz.setTerminalColumns(t.cols))), this.disposables.push(this.addSocketListener(this.socket, "close", ()=>this.dispose())), this.disposables.push(this.addSocketListener(this.socket, "error", ()=>this.dispose()));
    }
    dispose() {
        for (const t of this.disposables)t.dispose();
        this.trzsz = null;
    }
    uploadFiles(e) {
        return t(this, void 0, void 0, function*() {
            if (this.trzsz) return this.trzsz.uploadFiles(e);
            throw new Error("Addon has not been activated");
        });
    }
    addSocketListener(t, e, i) {
        return t.addEventListener(e, i), {
            dispose: ()=>{
                i && t.removeEventListener(e, i);
            }
        };
    }
}

},{"84ee08d945baaea5":"d5jf4","e72d965fc01fbcad":"fCgem","f1457235f5818f6a":"jhUEF","4dc1848a8a3dce6f":"cxohQ","9c751e0005e83403":"jhUEF","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}]},["5KAaQ","cuImQ"], "cuImQ", "parcelRequiref158")

</script>
</body>

</html>