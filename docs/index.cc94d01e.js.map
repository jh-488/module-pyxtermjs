{"mappings":"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","sources":["<anon>","node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js","node_modules/xterm-addon-web-links/lib/webpack:/WebLinksAddon/webpack/universalModuleDefinition","node_modules/xterm-addon-web-links/lib/webpack:/WebLinksAddon/src/WebLinkProvider.ts","node_modules/xterm-addon-web-links/lib/webpack:/WebLinksAddon/webpack/bootstrap","node_modules/xterm-addon-web-links/lib/webpack:/WebLinksAddon/src/WebLinksAddon.ts"],"sourcesContent":["!function(e, t) {\n    \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.WebLinksAddon = t() : e.WebLinksAddon = t();\n}(self, ()=>(()=>{\n        \"use strict\";\n        var e = {\n            6: (e, t)=>{\n                Object.defineProperty(t, \"__esModule\", {\n                    value: !0\n                }), t.LinkComputer = t.WebLinkProvider = void 0, t.WebLinkProvider = class {\n                    constructor(e, t, n, i = {}){\n                        this._terminal = e, this._regex = t, this._handler = n, this._options = i;\n                    }\n                    provideLinks(e, t) {\n                        const i = n.computeLink(e, this._regex, this._terminal, this._handler);\n                        t(this._addCallbacks(i));\n                    }\n                    _addCallbacks(e) {\n                        return e.map((e)=>(e.leave = this._options.leave, e.hover = (t, n)=>{\n                                if (this._options.hover) {\n                                    const { range: i } = e;\n                                    this._options.hover(t, n, i);\n                                }\n                            }, e));\n                    }\n                };\n                class n {\n                    static computeLink(e, t, i, r) {\n                        const o = new RegExp(t.source, (t.flags || \"\") + \"g\"), [s, a] = n._getWindowedLineStrings(e - 1, i), c = s.join(\"\");\n                        let d;\n                        const l = [];\n                        for(; d = o.exec(c);){\n                            const e = d[0];\n                            try {\n                                const t = new URL(e), n = decodeURI(t.toString());\n                                if (e !== n && e + \"/\" !== n) continue;\n                            } catch (e) {\n                                continue;\n                            }\n                            const [t, o] = n._mapStrIdx(i, a, 0, d.index), [s, c] = n._mapStrIdx(i, t, o, e.length);\n                            if (-1 === t || -1 === o || -1 === s || -1 === c) continue;\n                            const p = {\n                                start: {\n                                    x: o + 1,\n                                    y: t + 1\n                                },\n                                end: {\n                                    x: c,\n                                    y: s + 1\n                                }\n                            };\n                            l.push({\n                                range: p,\n                                text: e,\n                                activate: r\n                            });\n                        }\n                        return l;\n                    }\n                    static _getWindowedLineStrings(e, t) {\n                        let n, i = e, r = e, o = 0, s = \"\";\n                        const a = [];\n                        if (n = t.buffer.active.getLine(e)) {\n                            const e = n.translateToString(!0);\n                            if (n.isWrapped && \" \" !== e[0]) {\n                                for(o = 0; (n = t.buffer.active.getLine(--i)) && o < 2048 && (s = n.translateToString(!0), o += s.length, a.push(s), n.isWrapped && -1 === s.indexOf(\" \")););\n                                a.reverse();\n                            }\n                            for(a.push(e), o = 0; (n = t.buffer.active.getLine(++r)) && n.isWrapped && o < 2048 && (s = n.translateToString(!0), o += s.length, a.push(s), -1 === s.indexOf(\" \")););\n                        }\n                        return [\n                            a,\n                            i\n                        ];\n                    }\n                    static _mapStrIdx(e, t, n, i) {\n                        const r = e.buffer.active, o = r.getNullCell();\n                        let s = n;\n                        for(; i;){\n                            const e = r.getLine(t);\n                            if (!e) return [\n                                -1,\n                                -1\n                            ];\n                            for(let n = s; n < e.length; ++n){\n                                e.getCell(n, o);\n                                const s = o.getChars();\n                                if (o.getWidth() && (i -= s.length || 1, n === e.length - 1 && \"\" === s)) {\n                                    const e = r.getLine(t + 1);\n                                    e && e.isWrapped && (e.getCell(0, o), 2 === o.getWidth() && (i += 1));\n                                }\n                                if (i < 0) return [\n                                    t,\n                                    n\n                                ];\n                            }\n                            t++, s = 0;\n                        }\n                        return [\n                            t,\n                            s\n                        ];\n                    }\n                }\n                t.LinkComputer = n;\n            }\n        }, t = {};\n        function n(i) {\n            var r = t[i];\n            if (void 0 !== r) return r.exports;\n            var o = t[i] = {\n                exports: {}\n            };\n            return e[i](o, o.exports, n), o.exports;\n        }\n        var i = {};\n        return (()=>{\n            var e = i;\n            Object.defineProperty(e, \"__esModule\", {\n                value: !0\n            }), e.WebLinksAddon = void 0;\n            const t = n(6), r = /https?:[/]{2}[^\\s\"'!*(){}|\\\\\\^<>`]*[^\\s\"':,.!?{}|\\\\\\^~\\[\\]`()<>]/;\n            function o(e, t) {\n                const n = window.open();\n                if (n) {\n                    try {\n                        n.opener = null;\n                    } catch (e) {}\n                    n.location.href = t;\n                } else console.warn(\"Opening link blocked as opener could not be cleared\");\n            }\n            e.WebLinksAddon = class {\n                constructor(e = o, t = {}){\n                    this._handler = e, this._options = t;\n                }\n                activate(e) {\n                    this._terminal = e;\n                    const n = this._options, i = n.urlRegex || r;\n                    this._linkProvider = this._terminal.registerLinkProvider(new t.WebLinkProvider(this._terminal, i, this._handler, n));\n                }\n                dispose() {\n                    var e;\n                    null === (e = this._linkProvider) || void 0 === e || e.dispose();\n                }\n            };\n        })(), i;\n    })());\n\n//# sourceMappingURL=index.cc94d01e.js.map\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.WebLinksAddon=t():e.WebLinksAddon=t()}(self,(()=>(()=>{\"use strict\";var e={6:(e,t)=>{Object.defineProperty(t,\"__esModule\",{value:!0}),t.LinkComputer=t.WebLinkProvider=void 0,t.WebLinkProvider=class{constructor(e,t,n,i={}){this._terminal=e,this._regex=t,this._handler=n,this._options=i}provideLinks(e,t){const i=n.computeLink(e,this._regex,this._terminal,this._handler);t(this._addCallbacks(i))}_addCallbacks(e){return e.map((e=>(e.leave=this._options.leave,e.hover=(t,n)=>{if(this._options.hover){const{range:i}=e;this._options.hover(t,n,i)}},e)))}};class n{static computeLink(e,t,i,r){const o=new RegExp(t.source,(t.flags||\"\")+\"g\"),[s,a]=n._getWindowedLineStrings(e-1,i),c=s.join(\"\");let d;const l=[];for(;d=o.exec(c);){const e=d[0];try{const t=new URL(e),n=decodeURI(t.toString());if(e!==n&&e+\"/\"!==n)continue}catch(e){continue}const[t,o]=n._mapStrIdx(i,a,0,d.index),[s,c]=n._mapStrIdx(i,t,o,e.length);if(-1===t||-1===o||-1===s||-1===c)continue;const p={start:{x:o+1,y:t+1},end:{x:c,y:s+1}};l.push({range:p,text:e,activate:r})}return l}static _getWindowedLineStrings(e,t){let n,i=e,r=e,o=0,s=\"\";const a=[];if(n=t.buffer.active.getLine(e)){const e=n.translateToString(!0);if(n.isWrapped&&\" \"!==e[0]){for(o=0;(n=t.buffer.active.getLine(--i))&&o<2048&&(s=n.translateToString(!0),o+=s.length,a.push(s),n.isWrapped&&-1===s.indexOf(\" \")););a.reverse()}for(a.push(e),o=0;(n=t.buffer.active.getLine(++r))&&n.isWrapped&&o<2048&&(s=n.translateToString(!0),o+=s.length,a.push(s),-1===s.indexOf(\" \")););}return[a,i]}static _mapStrIdx(e,t,n,i){const r=e.buffer.active,o=r.getNullCell();let s=n;for(;i;){const e=r.getLine(t);if(!e)return[-1,-1];for(let n=s;n<e.length;++n){e.getCell(n,o);const s=o.getChars();if(o.getWidth()&&(i-=s.length||1,n===e.length-1&&\"\"===s)){const e=r.getLine(t+1);e&&e.isWrapped&&(e.getCell(0,o),2===o.getWidth()&&(i+=1))}if(i<0)return[t,n]}t++,s=0}return[t,s]}}t.LinkComputer=n}},t={};function n(i){var r=t[i];if(void 0!==r)return r.exports;var o=t[i]={exports:{}};return e[i](o,o.exports,n),o.exports}var i={};return(()=>{var e=i;Object.defineProperty(e,\"__esModule\",{value:!0}),e.WebLinksAddon=void 0;const t=n(6),r=/https?:[/]{2}[^\\s\"'!*(){}|\\\\\\^<>`]*[^\\s\"':,.!?{}|\\\\\\^~\\[\\]`()<>]/;function o(e,t){const n=window.open();if(n){try{n.opener=null}catch(e){}n.location.href=t}else console.warn(\"Opening link blocked as opener could not be cleared\")}e.WebLinksAddon=class{constructor(e=o,t={}){this._handler=e,this._options=t}activate(e){this._terminal=e;const n=this._options,i=n.urlRegex||r;this._linkProvider=this._terminal.registerLinkProvider(new t.WebLinkProvider(this._terminal,i,this._handler,n))}dispose(){var e;null===(e=this._linkProvider)||void 0===e||e.dispose()}}})(),i})()));\n//# sourceMappingURL=xterm-addon-web-links.js.map","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"WebLinksAddon\"] = factory();\n\telse\n\t\troot[\"WebLinksAddon\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { ILinkProvider, ILink, Terminal, IViewportRange, IBufferLine } from 'xterm';\n\nexport interface ILinkProviderOptions {\n  hover?(event: MouseEvent, text: string, location: IViewportRange): void;\n  leave?(event: MouseEvent, text: string): void;\n  urlRegex?: RegExp;\n}\n\nexport class WebLinkProvider implements ILinkProvider {\n\n  constructor(\n    private readonly _terminal: Terminal,\n    private readonly _regex: RegExp,\n    private readonly _handler: (event: MouseEvent, uri: string) => void,\n    private readonly _options: ILinkProviderOptions = {}\n  ) {\n\n  }\n\n  public provideLinks(y: number, callback: (links: ILink[] | undefined) => void): void {\n    const links = LinkComputer.computeLink(y, this._regex, this._terminal, this._handler);\n    callback(this._addCallbacks(links));\n  }\n\n  private _addCallbacks(links: ILink[]): ILink[] {\n    return links.map(link => {\n      link.leave = this._options.leave;\n      link.hover = (event: MouseEvent, uri: string): void => {\n        if (this._options.hover) {\n          const { range } = link;\n          this._options.hover(event, uri, range);\n        }\n      };\n      return link;\n    });\n  }\n}\n\nexport class LinkComputer {\n  public static computeLink(y: number, regex: RegExp, terminal: Terminal, activate: (event: MouseEvent, uri: string) => void): ILink[] {\n    const rex = new RegExp(regex.source, (regex.flags || '') + 'g');\n\n    const [lines, startLineIndex] = LinkComputer._getWindowedLineStrings(y - 1, terminal);\n    const line = lines.join('');\n\n    let match;\n    const result: ILink[] = [];\n\n    while (match = rex.exec(line)) {\n      const text = match[0];\n\n      // check via URL if the matched text would form a proper url\n      // NOTE: This outsources the ugly url parsing to the browser.\n      // To avoid surprising auto expansion from URL we additionally\n      // check afterwards if the provided string resembles the parsed\n      // one close enough:\n      // - decodeURI  decode path segement back to byte repr\n      //              to detect unicode auto conversion correctly\n      // - append /   also match domain urls w'o any path notion\n      try {\n        const url = new URL(text);\n        const urlText = decodeURI(url.toString());\n        if (text !== urlText && text + '/' !== urlText) {\n          continue;\n        }\n      } catch (e) {\n        continue;\n      }\n\n      // map string positions back to buffer positions\n      // values are 0-based right side excluding\n      const [startY, startX] = LinkComputer._mapStrIdx(terminal, startLineIndex, 0, match.index);\n      const [endY, endX] = LinkComputer._mapStrIdx(terminal, startY, startX, text.length);\n\n      if (startY === -1 || startX === -1 || endY === -1 || endX === -1) {\n        continue;\n      }\n\n      // range expects values 1-based right side including, thus +1 except for endX\n      const range = {\n        start: {\n          x: startX + 1,\n          y: startY + 1\n        },\n        end: {\n          x: endX,\n          y: endY + 1\n        }\n      };\n\n      result.push({ range, text, activate });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get wrapped content lines for the current line index.\n   * The top/bottom line expansion stops at whitespaces or length > 2048.\n   * Returns an array with line strings and the top line index.\n   *\n   * NOTE: We pull line strings with trimRight=true on purpose to make sure\n   * to correctly match urls with early wrapped wide chars. This corrupts the string index\n   * for 1:1 backmapping to buffer positions, thus needs an additional correction in _mapStrIdx.\n   */\n  private static _getWindowedLineStrings(lineIndex: number, terminal: Terminal): [string[], number] {\n    let line: IBufferLine | undefined;\n    let topIdx = lineIndex;\n    let bottomIdx = lineIndex;\n    let length = 0;\n    let content = '';\n    const lines: string[] = [];\n\n    if ((line = terminal.buffer.active.getLine(lineIndex))) {\n      const currentContent = line.translateToString(true);\n\n      // expand top, stop on whitespaces or length > 2048\n      if (line.isWrapped && currentContent[0] !== ' ') {\n        length = 0;\n        while ((line = terminal.buffer.active.getLine(--topIdx)) && length < 2048) {\n          content = line.translateToString(true);\n          length += content.length;\n          lines.push(content);\n          if (!line.isWrapped || content.indexOf(' ') !== -1) {\n            break;\n          }\n        }\n        lines.reverse();\n      }\n\n      // append current line\n      lines.push(currentContent);\n\n      // expand bottom, stop on whitespaces or length > 2048\n      length = 0;\n      while ((line = terminal.buffer.active.getLine(++bottomIdx)) && line.isWrapped && length < 2048) {\n        content = line.translateToString(true);\n        length += content.length;\n        lines.push(content);\n        if (content.indexOf(' ') !== -1) {\n          break;\n        }\n      }\n    }\n    return [lines, topIdx];\n  }\n\n  /**\n   * Map a string index back to buffer positions.\n   * Returns buffer position as [lineIndex, columnIndex] 0-based,\n   * or [-1, -1] in case the lookup ran into a non-existing line.\n   */\n  private static _mapStrIdx(terminal: Terminal, lineIndex: number, rowIndex: number, stringIndex: number): [number, number] {\n    const buf = terminal.buffer.active;\n    const cell = buf.getNullCell();\n    let start = rowIndex;\n    while (stringIndex) {\n      const line = buf.getLine(lineIndex);\n      if (!line) {\n        return [-1, -1];\n      }\n      for (let i = start; i < line.length; ++i) {\n        line.getCell(i, cell);\n        const chars = cell.getChars();\n        const width = cell.getWidth();\n        if (width) {\n          stringIndex -= chars.length || 1;\n\n          // correct stringIndex for early wrapped wide chars:\n          // - currently only happens at last cell\n          // - cells to the right are reset with chars='' and width=1 in InputHandler.print\n          // - follow-up line must be wrapped and contain wide char at first cell\n          // --> if all these conditions are met, correct stringIndex by +1\n          if (i === line.length - 1 && chars === '') {\n            const line = buf.getLine(lineIndex + 1);\n            if (line && line.isWrapped) {\n              line.getCell(0, cell);\n              if (cell.getWidth() === 2) {\n                stringIndex += 1;\n              }\n            }\n          }\n        }\n        if (stringIndex < 0) {\n          return [lineIndex, i];\n        }\n      }\n      lineIndex++;\n      start = 0;\n    }\n    return [lineIndex, start];\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, ITerminalAddon, IDisposable } from 'xterm';\nimport { ILinkProviderOptions, WebLinkProvider } from './WebLinkProvider';\n\n// consider everthing starting with http:// or https://\n// up to first whitespace, `\"` or `'` as url\n// NOTE: The repeated end clause is needed to not match a dangling `:`\n// resembling the old (...)*([^:\"\\'\\\\s]) final path clause\n// additionally exclude early + final:\n// - unsafe from rfc3986: !*'()\n// - unsafe chars from rfc1738: {}|\\^~[]` (minus [] as we need them for ipv6 adresses, also allow ~)\n// also exclude as finals:\n// - final interpunction like ,.!?\n// - any sort of brackets <>()[]{} (not spec conform, but often used to enclose urls)\n// - unsafe chars from rfc1738: {}|\\^~[]`\nconst strictUrlRegex = /https?:[/]{2}[^\\s\"'!*(){}|\\\\\\^<>`]*[^\\s\"':,.!?{}|\\\\\\^~\\[\\]`()<>]/;\n\n\nfunction handleLink(event: MouseEvent, uri: string): void {\n  const newWindow = window.open();\n  if (newWindow) {\n    try {\n      newWindow.opener = null;\n    } catch {\n      // no-op, Electron can throw\n    }\n    newWindow.location.href = uri;\n  } else {\n    console.warn('Opening link blocked as opener could not be cleared');\n  }\n}\n\nexport class WebLinksAddon implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n  private _linkProvider: IDisposable | undefined;\n\n  constructor(\n    private _handler: (event: MouseEvent, uri: string) => void = handleLink,\n    private _options: ILinkProviderOptions = {}\n  ) {\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    const options = this._options as ILinkProviderOptions;\n    const regex = options.urlRegex || strictUrlRegex;\n    this._linkProvider = this._terminal.registerLinkProvider(new WebLinkProvider(this._terminal, regex, this._handler, options));\n  }\n\n  public dispose(): void {\n    this._linkProvider?.dispose();\n  }\n}\n"],"names":["e","t","self","i","Object","defineProperty","value","LinkComputer","WebLinkProvider","constructor","n","_terminal","_regex","_handler","_options","provideLinks","computeLink","_addCallbacks","map","leave","hover","range","r","d","o","RegExp","source","flags","s","a","_getWindowedLineStrings","c","join","l","exec","URL","decodeURI","toString","_mapStrIdx","index","length","p","start","x","y","end","push","text","activate","buffer","active","getLine","translateToString","isWrapped","indexOf","reverse","getNullCell","getCell","getChars","getWidth","WebLinksAddon","exports","window","open","opener","location","href","console","warn","urlRegex","_linkProvider","registerLinkProvider","dispose","module","define","amd","root","factory","callback","links","this","link","event","uri","regex","terminal","rex","lines","startLineIndex","line","match","result","url","urlText","startY","startX","endY","endX","lineIndex","topIdx","bottomIdx","content","currentContent","rowIndex","stringIndex","buf","cell","chars","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","strictUrlRegex","handleLink","newWindow","options"],"version":3,"file":"index.cc94d01e.js.map"}