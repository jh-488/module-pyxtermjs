{"mappings":"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","sources":["node_modules/xterm-addon-search/lib/xterm-addon-search.js","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/webpack/universalModuleDefinition","node_modules/xterm-addon-search/lib/src/common/EventEmitter.ts","node_modules/xterm-addon-search/lib/src/common/Lifecycle.ts","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/webpack/bootstrap","node_modules/xterm-addon-search/lib/webpack:/SearchAddon/src/SearchAddon.ts"],"sourcesContent":[null,"(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SearchAddon\"] = factory();\n\telse\n\t\troot[\"SearchAddon\"] = factory();\n})(self, () => {\nreturn ","/**\n * Copyright (c) 2019 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\ninterface IListener<T, U = void> {\n  (arg1: T, arg2: U): void;\n}\n\nexport interface IEvent<T, U = void> {\n  (listener: (arg1: T, arg2: U) => any): IDisposable;\n}\n\nexport interface IEventEmitter<T, U = void> {\n  event: IEvent<T, U>;\n  fire(arg1: T, arg2: U): void;\n  dispose(): void;\n}\n\nexport class EventEmitter<T, U = void> implements IEventEmitter<T, U> {\n  private _listeners: IListener<T, U>[] = [];\n  private _event?: IEvent<T, U>;\n  private _disposed: boolean = false;\n\n  public get event(): IEvent<T, U> {\n    if (!this._event) {\n      this._event = (listener: (arg1: T, arg2: U) => any) => {\n        this._listeners.push(listener);\n        const disposable = {\n          dispose: () => {\n            if (!this._disposed) {\n              for (let i = 0; i < this._listeners.length; i++) {\n                if (this._listeners[i] === listener) {\n                  this._listeners.splice(i, 1);\n                  return;\n                }\n              }\n            }\n          }\n        };\n        return disposable;\n      };\n    }\n    return this._event;\n  }\n\n  public fire(arg1: T, arg2: U): void {\n    const queue: IListener<T, U>[] = [];\n    for (let i = 0; i < this._listeners.length; i++) {\n      queue.push(this._listeners[i]);\n    }\n    for (let i = 0; i < queue.length; i++) {\n      queue[i].call(undefined, arg1, arg2);\n    }\n  }\n\n  public dispose(): void {\n    this.clearListeners();\n    this._disposed = true;\n  }\n\n  public clearListeners(): void {\n    if (this._listeners) {\n      this._listeners.length = 0;\n    }\n  }\n}\n\nexport function forwardEvent<T>(from: IEvent<T>, to: IEventEmitter<T>): IDisposable {\n  return from(e => to.fire(e));\n}\n","/**\n * Copyright (c) 2018 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { IDisposable } from 'common/Types';\n\n/**\n * A base class that can be extended to provide convenience methods for managing the lifecycle of an\n * object and its components.\n */\nexport abstract class Disposable implements IDisposable {\n  protected _disposables: IDisposable[] = [];\n  protected _isDisposed: boolean = false;\n\n  /**\n   * Disposes the object, triggering the `dispose` method on all registered IDisposables.\n   */\n  public dispose(): void {\n    this._isDisposed = true;\n    for (const d of this._disposables) {\n      d.dispose();\n    }\n    this._disposables.length = 0;\n  }\n\n  /**\n   * Registers a disposable object.\n   * @param d The disposable to register.\n   * @returns The disposable.\n   */\n  public register<T extends IDisposable>(d: T): T {\n    this._disposables.push(d);\n    return d;\n  }\n\n  /**\n   * Unregisters a disposable object if it has been registered, if not do\n   * nothing.\n   * @param d The disposable to unregister.\n   */\n  public unregister<T extends IDisposable>(d: T): void {\n    const index = this._disposables.indexOf(d);\n    if (index !== -1) {\n      this._disposables.splice(index, 1);\n    }\n  }\n}\n\nexport class MutableDisposable<T extends IDisposable> implements IDisposable {\n  private _value?: T;\n  private _isDisposed = false;\n\n  /**\n   * Gets the value if it exists.\n   */\n  public get value(): T | undefined {\n    return this._isDisposed ? undefined : this._value;\n  }\n\n  /**\n   * Sets the value, disposing of the old value if it exists.\n   */\n  public set value(value: T | undefined) {\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    this._value?.dispose();\n    this._value = value;\n  }\n\n  /**\n   * Resets the stored value and disposes of the previously stored value.\n   */\n  public clear(): void {\n    this.value = undefined;\n  }\n\n  public dispose(): void {\n    this._isDisposed = true;\n    this._value?.dispose();\n    this._value = undefined;\n  }\n}\n\n/**\n * Wrap a function in a disposable.\n */\nexport function toDisposable(f: () => void): IDisposable {\n  return { dispose: f };\n}\n\n/**\n * Dispose of all disposables in an array and set its length to 0.\n */\nexport function disposeArray(disposables: IDisposable[]): void {\n  for (const d of disposables) {\n    d.dispose();\n  }\n  disposables.length = 0;\n}\n\n/**\n * Creates a disposable that will dispose of an array of disposables when disposed.\n */\nexport function getDisposeArrayDisposable(array: IDisposable[]): IDisposable {\n  return { dispose: () => disposeArray(array) };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/**\n * Copyright (c) 2017 The xterm.js authors. All rights reserved.\n * @license MIT\n */\n\nimport { Terminal, IDisposable, ITerminalAddon, IDecoration } from 'xterm';\nimport { EventEmitter } from 'common/EventEmitter';\nimport { Disposable, toDisposable, disposeArray, MutableDisposable } from 'common/Lifecycle';\n\nexport interface ISearchOptions {\n  regex?: boolean;\n  wholeWord?: boolean;\n  caseSensitive?: boolean;\n  incremental?: boolean;\n  decorations?: ISearchDecorationOptions;\n  noScroll?: boolean;\n}\n\ninterface ISearchDecorationOptions {\n  matchBackground?: string;\n  matchBorder?: string;\n  matchOverviewRuler: string;\n  activeMatchBackground?: string;\n  activeMatchBorder?: string;\n  activeMatchColorOverviewRuler: string;\n}\n\nexport interface ISearchPosition {\n  startCol: number;\n  startRow: number;\n}\n\nexport interface ISearchAddonOptions {\n  highlightLimit: number;\n}\n\nexport interface ISearchResult {\n  term: string;\n  col: number;\n  row: number;\n  size: number;\n}\n\ntype LineCacheEntry = [\n  /**\n   * The string representation of a line (as opposed to the buffer cell representation).\n   */\n  lineAsString: string,\n  /**\n   * The offsets where each line starts when the entry describes a wrapped line.\n   */\n  lineOffsets: number[]\n];\n\ninterface IHighlight extends IDisposable {\n  decoration: IDecoration;\n  match: ISearchResult;\n}\n\nconst NON_WORD_CHARACTERS = ' ~!@#$%^&*()+`-=[]{}|\\\\;:\"\\',./<>?';\nconst LINES_CACHE_TIME_TO_LIVE = 15 * 1000; // 15 secs\nconst DEFAULT_HIGHLIGHT_LIMIT = 1000;\n\nexport class SearchAddon extends Disposable implements ITerminalAddon {\n  private _terminal: Terminal | undefined;\n  private _cachedSearchTerm: string | undefined;\n  private _highlightedLines: Set<number> = new Set();\n  private _highlightDecorations: IHighlight[] = [];\n  private _selectedDecoration: MutableDisposable<IHighlight> = this.register(new MutableDisposable());\n  private _highlightLimit: number;\n  private _lastSearchOptions: ISearchOptions | undefined;\n  private _highlightTimeout: number | undefined;\n  /**\n   * translateBufferLineToStringWithWrap is a fairly expensive call.\n   * We memoize the calls into an array that has a time based ttl.\n   * _linesCache is also invalidated when the terminal cursor moves.\n   */\n  private _linesCache: LineCacheEntry[] | undefined;\n  private _linesCacheTimeoutId = 0;\n  private _cursorMoveListener: IDisposable | undefined;\n  private _resizeListener: IDisposable | undefined;\n\n  private readonly _onDidChangeResults = this.register(new EventEmitter<{ resultIndex: number, resultCount: number }>());\n  public readonly onDidChangeResults = this._onDidChangeResults.event;\n\n  constructor(options?: Partial<ISearchAddonOptions>) {\n    super();\n\n    this._highlightLimit = options?.highlightLimit ?? DEFAULT_HIGHLIGHT_LIMIT;\n  }\n\n  public activate(terminal: Terminal): void {\n    this._terminal = terminal;\n    this.register(this._terminal.onWriteParsed(() => this._updateMatches()));\n    this.register(this._terminal.onResize(() => this._updateMatches()));\n    this.register(toDisposable(() => this.clearDecorations()));\n  }\n\n  private _updateMatches(): void {\n    if (this._highlightTimeout) {\n      window.clearTimeout(this._highlightTimeout);\n    }\n    if (this._cachedSearchTerm && this._lastSearchOptions?.decorations) {\n      this._highlightTimeout = setTimeout(() => {\n        const term = this._cachedSearchTerm;\n        this._cachedSearchTerm = undefined;\n        this.findPrevious(term!, { ...this._lastSearchOptions, incremental: true, noScroll: true });\n      }, 200);\n    }\n  }\n\n  public clearDecorations(retainCachedSearchTerm?: boolean): void {\n    this._selectedDecoration.clear();\n    disposeArray(this._highlightDecorations);\n    this._highlightDecorations = [];\n    this._highlightedLines.clear();\n    if (!retainCachedSearchTerm) {\n      this._cachedSearchTerm = undefined;\n    }\n  }\n\n  /**\n   * Find the next instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findNext(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findNextAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _highlightAllMatches(term: string, searchOptions: ISearchOptions): void {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!term || term.length === 0) {\n      this.clearDecorations();\n      return;\n    }\n    searchOptions = searchOptions || {};\n\n    // new search, clear out the old decorations\n    this.clearDecorations(true);\n\n    const searchResultsWithHighlight: ISearchResult[] = [];\n    let prevResult: ISearchResult | undefined = undefined;\n    let result = this._find(term, 0, 0, searchOptions);\n    while (result && (prevResult?.row !== result.row || prevResult?.col !== result.col)) {\n      if (searchResultsWithHighlight.length >= this._highlightLimit) {\n        break;\n      }\n      prevResult = result;\n      searchResultsWithHighlight.push(prevResult);\n      result = this._find(\n        term,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? prevResult.row + 1 : prevResult.row,\n        prevResult.col + prevResult.term.length >= this._terminal.cols ? 0 : prevResult.col + 1,\n        searchOptions\n      );\n    }\n    for (const match of searchResultsWithHighlight) {\n      const decoration = this._createResultDecoration(match, searchOptions.decorations!);\n      if (decoration) {\n        this._highlightedLines.add(decoration.marker.line);\n        this._highlightDecorations.push({ decoration, match, dispose() { decoration.dispose(); } });\n      }\n    }\n  }\n\n  private _find(term: string, startRow: number, startCol: number, searchOptions?: ISearchOptions): ISearchResult | undefined {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return undefined;\n    }\n    if (startCol > this._terminal.cols) {\n      throw new Error(`Invalid col: ${startCol} to search in terminal of ${this._terminal.cols} cols`);\n    }\n\n    let result: ISearchResult | undefined = undefined;\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    return result;\n  }\n\n  private _findNextAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startCol = 0;\n    let startRow = 0;\n    if (prevSelectedPos) {\n      if (this._cachedSearchTerm === term) {\n        startCol = prevSelectedPos.end.x;\n        startRow = prevSelectedPos.end.y;\n      } else {\n        startCol = prevSelectedPos.start.x;\n        startRow = prevSelectedPos.start.y;\n      }\n    }\n\n    this._initLinesCache();\n\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    // Search startRow\n    let result = this._findInLine(term, searchPosition, searchOptions);\n    // Search from startRow + 1 to end\n    if (!result) {\n\n      for (let y = startRow + 1; y < this._terminal.buffer.active.baseY + this._terminal.rows; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        // If the current line is wrapped line, increase index of column to ignore the previous scan\n        // Otherwise, reset beginning column index to zero with set new unwrapped line index\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the bottom and didn't search from the very top wrap back up\n    if (!result && startRow !== 0) {\n      for (let y = 0; y < startRow; y++) {\n        searchPosition.startRow = y;\n        searchPosition.startCol = 0;\n        result = this._findInLine(term, searchPosition, searchOptions);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // If there is only one result, wrap back and return selection if it exists.\n    if (!result && prevSelectedPos) {\n      searchPosition.startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = 0;\n      result = this._findInLine(term, searchPosition, searchOptions);\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n  /**\n   * Find the previous instance of the term, then scroll to and select it. If it\n   * doesn't exist, do nothing.\n   * @param term The search term.\n   * @param searchOptions Search options.\n   * @returns Whether a result was found.\n   */\n  public findPrevious(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    this._lastSearchOptions = searchOptions;\n    if (searchOptions?.decorations) {\n      if (this._cachedSearchTerm === undefined || term !== this._cachedSearchTerm) {\n        this._highlightAllMatches(term, searchOptions);\n      }\n    }\n\n    const found = this._findPreviousAndSelect(term, searchOptions);\n    this._fireResults(searchOptions);\n    this._cachedSearchTerm = term;\n\n    return found;\n  }\n\n  private _fireResults(searchOptions?: ISearchOptions): void {\n    if (searchOptions?.decorations) {\n      let resultIndex = -1;\n      if (this._selectedDecoration.value) {\n        const selectedMatch = this._selectedDecoration.value.match;\n        for (let i = 0; i < this._highlightDecorations.length; i++) {\n          const match = this._highlightDecorations[i].match;\n          if (match.row === selectedMatch.row && match.col === selectedMatch.col && match.size === selectedMatch.size) {\n            resultIndex = i;\n            break;\n          }\n        }\n      }\n      this._onDidChangeResults.fire({ resultIndex, resultCount: this._highlightDecorations.length });\n    }\n  }\n\n  private _findPreviousAndSelect(term: string, searchOptions?: ISearchOptions): boolean {\n    if (!this._terminal) {\n      throw new Error('Cannot use addon until it has been loaded');\n    }\n    if (!this._terminal || !term || term.length === 0) {\n      this._terminal?.clearSelection();\n      this.clearDecorations();\n      return false;\n    }\n\n    const prevSelectedPos = this._terminal.getSelectionPosition();\n    this._terminal.clearSelection();\n\n    let startRow = this._terminal.buffer.active.baseY + this._terminal.rows - 1;\n    let startCol = this._terminal.cols;\n    const isReverseSearch = true;\n\n    this._initLinesCache();\n    const searchPosition: ISearchPosition = {\n      startRow,\n      startCol\n    };\n\n    let result: ISearchResult | undefined;\n    if (prevSelectedPos) {\n      searchPosition.startRow = startRow = prevSelectedPos.start.y;\n      searchPosition.startCol = startCol = prevSelectedPos.start.x;\n      if (this._cachedSearchTerm !== term) {\n        // Try to expand selection to right first.\n        result = this._findInLine(term, searchPosition, searchOptions, false);\n        if (!result) {\n          // If selection was not able to be expanded to the right, then try reverse search\n          searchPosition.startRow = startRow = prevSelectedPos.end.y;\n          searchPosition.startCol = startCol = prevSelectedPos.end.x;\n        }\n      }\n    }\n\n    if (!result) {\n      result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n    }\n\n    // Search from startRow - 1 to top\n    if (!result) {\n      searchPosition.startCol = Math.max(searchPosition.startCol, this._terminal.cols);\n      for (let y = startRow - 1; y >= 0; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n    // If we hit the top and didn't search from the very bottom wrap back down\n    if (!result && startRow !== (this._terminal.buffer.active.baseY + this._terminal.rows - 1)) {\n      for (let y = (this._terminal.buffer.active.baseY + this._terminal.rows - 1); y >= startRow; y--) {\n        searchPosition.startRow = y;\n        result = this._findInLine(term, searchPosition, searchOptions, isReverseSearch);\n        if (result) {\n          break;\n        }\n      }\n    }\n\n    // Set selection and scroll if a result was found\n    return this._selectResult(result, searchOptions?.decorations, searchOptions?.noScroll);\n  }\n\n  /**\n   * Sets up a line cache with a ttl\n   */\n  private _initLinesCache(): void {\n    const terminal = this._terminal!;\n    if (!this._linesCache) {\n      this._linesCache = new Array(terminal.buffer.active.length);\n      this._cursorMoveListener = terminal.onCursorMove(() => this._destroyLinesCache());\n      this._resizeListener = terminal.onResize(() => this._destroyLinesCache());\n    }\n\n    window.clearTimeout(this._linesCacheTimeoutId);\n    this._linesCacheTimeoutId = window.setTimeout(() => this._destroyLinesCache(), LINES_CACHE_TIME_TO_LIVE);\n  }\n\n  private _destroyLinesCache(): void {\n    this._linesCache = undefined;\n    if (this._cursorMoveListener) {\n      this._cursorMoveListener.dispose();\n      this._cursorMoveListener = undefined;\n    }\n    if (this._resizeListener) {\n      this._resizeListener.dispose();\n      this._resizeListener = undefined;\n    }\n    if (this._linesCacheTimeoutId) {\n      window.clearTimeout(this._linesCacheTimeoutId);\n      this._linesCacheTimeoutId = 0;\n    }\n  }\n\n  /**\n   * A found substring is a whole word if it doesn't have an alphanumeric character directly\n   * adjacent to it.\n   * @param searchIndex starting indext of the potential whole word substring\n   * @param line entire string in which the potential whole word was found\n   * @param term the substring that starts at searchIndex\n   */\n  private _isWholeWord(searchIndex: number, line: string, term: string): boolean {\n    return ((searchIndex === 0) || (NON_WORD_CHARACTERS.includes(line[searchIndex - 1]))) &&\n      (((searchIndex + term.length) === line.length) || (NON_WORD_CHARACTERS.includes(line[searchIndex + term.length])));\n  }\n\n  /**\n   * Searches a line for a search term. Takes the provided terminal line and searches the text line,\n   * which may contain subsequent terminal lines if the text is wrapped. If the provided line number\n   * is part of a wrapped text line that started on an earlier line then it is skipped since it will\n   * be properly searched when the terminal line that the text starts on is searched.\n   * @param term The search term.\n   * @param searchPosition The position to start the search.\n   * @param searchOptions Search options.\n   * @param isReverseSearch Whether the search should start from the right side of the terminal and\n   * search to the left.\n   * @returns The search result if it was found.\n   */\n  protected _findInLine(term: string, searchPosition: ISearchPosition, searchOptions: ISearchOptions = {}, isReverseSearch: boolean = false): ISearchResult | undefined {\n    const terminal = this._terminal!;\n    const row = searchPosition.startRow;\n    const col = searchPosition.startCol;\n\n    // Ignore wrapped lines, only consider on unwrapped line (first row of command string).\n    const firstLine = terminal.buffer.active.getLine(row);\n    if (firstLine?.isWrapped) {\n      if (isReverseSearch) {\n        searchPosition.startCol += terminal.cols;\n        return;\n      }\n\n      // This will iterate until we find the line start.\n      // When we find it, we will search using the calculated start column.\n      searchPosition.startRow--;\n      searchPosition.startCol += terminal.cols;\n      return this._findInLine(term, searchPosition, searchOptions);\n    }\n    let cache = this._linesCache?.[row];\n    if (!cache) {\n      cache = this._translateBufferLineToStringWithWrap(row, true);\n      if (this._linesCache) {\n        this._linesCache[row] = cache;\n      }\n    }\n    const [stringLine, offsets] = cache;\n\n    const offset = this._bufferColsToStringOffset(row, col);\n    const searchTerm = searchOptions.caseSensitive ? term : term.toLowerCase();\n    const searchStringLine = searchOptions.caseSensitive ? stringLine : stringLine.toLowerCase();\n\n    let resultIndex = -1;\n    if (searchOptions.regex) {\n      const searchRegex = RegExp(searchTerm, 'g');\n      let foundTerm: RegExpExecArray | null;\n      if (isReverseSearch) {\n        // This loop will get the resultIndex of the _last_ regex match in the range 0..offset\n        while (foundTerm = searchRegex.exec(searchStringLine.slice(0, offset))) {\n          resultIndex = searchRegex.lastIndex - foundTerm[0].length;\n          term = foundTerm[0];\n          searchRegex.lastIndex -= (term.length - 1);\n        }\n      } else {\n        foundTerm = searchRegex.exec(searchStringLine.slice(offset));\n        if (foundTerm && foundTerm[0].length > 0) {\n          resultIndex = offset + (searchRegex.lastIndex - foundTerm[0].length);\n          term = foundTerm[0];\n        }\n      }\n    } else {\n      if (isReverseSearch) {\n        if (offset - searchTerm.length >= 0) {\n          resultIndex = searchStringLine.lastIndexOf(searchTerm, offset - searchTerm.length);\n        }\n      } else {\n        resultIndex = searchStringLine.indexOf(searchTerm, offset);\n      }\n    }\n\n    if (resultIndex >= 0) {\n      if (searchOptions.wholeWord && !this._isWholeWord(resultIndex, searchStringLine, term)) {\n        return;\n      }\n\n      // Adjust the row number and search index if needed since a \"line\" of text can span multiple\n      // rows\n      let startRowOffset = 0;\n      while (startRowOffset < offsets.length - 1 && resultIndex >= offsets[startRowOffset + 1]) {\n        startRowOffset++;\n      }\n      let endRowOffset = startRowOffset;\n      while (endRowOffset < offsets.length - 1 && resultIndex + term.length >= offsets[endRowOffset + 1]) {\n        endRowOffset++;\n      }\n      const startColOffset = resultIndex - offsets[startRowOffset];\n      const endColOffset = resultIndex + term.length - offsets[endRowOffset];\n      const startColIndex = this._stringLengthToBufferSize(row + startRowOffset, startColOffset);\n      const endColIndex = this._stringLengthToBufferSize(row + endRowOffset, endColOffset);\n      const size = endColIndex - startColIndex + terminal.cols * (endRowOffset - startRowOffset);\n\n      return {\n        term,\n        col: startColIndex,\n        row: row + startRowOffset,\n        size\n      };\n    }\n  }\n\n  private _stringLengthToBufferSize(row: number, offset: number): number {\n    const line = this._terminal!.buffer.active.getLine(row);\n    if (!line) {\n      return 0;\n    }\n    for (let i = 0; i < offset; i++) {\n      const cell = line.getCell(i);\n      if (!cell) {\n        break;\n      }\n      // Adjust the searchIndex to normalize emoji into single chars\n      const char = cell.getChars();\n      if (char.length > 1) {\n        offset -= char.length - 1;\n      }\n      // Adjust the searchIndex for empty characters following wide unicode\n      // chars (eg. CJK)\n      const nextCell = line.getCell(i + 1);\n      if (nextCell && nextCell.getWidth() === 0) {\n        offset++;\n      }\n    }\n    return offset;\n  }\n\n  private _bufferColsToStringOffset(startRow: number, cols: number): number {\n    const terminal = this._terminal!;\n    let lineIndex = startRow;\n    let offset = 0;\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (cols > 0 && line) {\n      for (let i = 0; i < cols && i < terminal.cols; i++) {\n        const cell = line.getCell(i);\n        if (!cell) {\n          break;\n        }\n        if (cell.getWidth()) {\n          // Treat null characters as whitespace to align with the translateToString API\n          offset += cell.getCode() === 0 ? 1 : cell.getChars().length;\n        }\n      }\n      lineIndex++;\n      line = terminal.buffer.active.getLine(lineIndex);\n      if (line && !line.isWrapped) {\n        break;\n      }\n      cols -= terminal.cols;\n    }\n    return offset;\n  }\n\n  /**\n   * Translates a buffer line to a string, including subsequent lines if they are wraps.\n   * Wide characters will count as two columns in the resulting string. This\n   * function is useful for getting the actual text underneath the raw selection\n   * position.\n   * @param lineIndex The index of the line being translated.\n   * @param trimRight Whether to trim whitespace to the right.\n   */\n  private _translateBufferLineToStringWithWrap(lineIndex: number, trimRight: boolean): LineCacheEntry {\n    const terminal = this._terminal!;\n    const strings = [];\n    const lineOffsets = [0];\n    let line = terminal.buffer.active.getLine(lineIndex);\n    while (line) {\n      const nextLine = terminal.buffer.active.getLine(lineIndex + 1);\n      const lineWrapsToNext = nextLine ? nextLine.isWrapped : false;\n      let string = line.translateToString(!lineWrapsToNext && trimRight);\n      if (lineWrapsToNext && nextLine) {\n        const lastCell = line.getCell(line.length - 1);\n        const lastCellIsNull = lastCell && lastCell.getCode() === 0 && lastCell.getWidth() === 1;\n        // a wide character wrapped to the next line\n        if (lastCellIsNull && nextLine.getCell(0)?.getWidth() === 2) {\n          string = string.slice(0, -1);\n        }\n      }\n      strings.push(string);\n      if (lineWrapsToNext) {\n        lineOffsets.push(lineOffsets[lineOffsets.length - 1] + string.length);\n      } else {\n        break;\n      }\n      lineIndex++;\n      line = nextLine;\n    }\n    return [strings.join(''), lineOffsets];\n  }\n\n  /**\n   * Selects and scrolls to a result.\n   * @param result The result to select.\n   * @returns Whether a result was selected.\n   */\n  private _selectResult(result: ISearchResult | undefined, options?: ISearchDecorationOptions, noScroll?: boolean): boolean {\n    const terminal = this._terminal!;\n    this._selectedDecoration.clear();\n    if (!result) {\n      terminal.clearSelection();\n      return false;\n    }\n    terminal.select(result.col, result.row, result.size);\n    if (options) {\n      const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n      if (marker) {\n        const decoration = terminal.registerDecoration({\n          marker,\n          x: result.col,\n          width: result.size,\n          backgroundColor: options.activeMatchBackground,\n          layer: 'top',\n          overviewRulerOptions: {\n            color: options.activeMatchColorOverviewRuler\n          }\n        });\n        if (decoration) {\n          const disposables: IDisposable[] = [];\n          disposables.push(marker);\n          disposables.push(decoration.onRender((e) => this._applyStyles(e, options.activeMatchBorder, true)));\n          disposables.push(decoration.onDispose(() => disposeArray(disposables)));\n          this._selectedDecoration.value = { decoration, match: result, dispose() { decoration.dispose(); } };\n        }\n      }\n    }\n\n    if (!noScroll) {\n      // If it is not in the viewport then we scroll else it just gets selected\n      if (result.row >= (terminal.buffer.active.viewportY + terminal.rows) || result.row < terminal.buffer.active.viewportY) {\n        let scroll = result.row - terminal.buffer.active.viewportY;\n        scroll -= Math.floor(terminal.rows / 2);\n        terminal.scrollLines(scroll);\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Applies styles to the decoration when it is rendered.\n   * @param element The decoration's element.\n   * @param borderColor The border color to apply.\n   * @param isActiveResult Whether the element is part of the active search result.\n   * @returns\n   */\n  private _applyStyles(element: HTMLElement, borderColor: string | undefined, isActiveResult: boolean): void {\n    if (!element.classList.contains('xterm-find-result-decoration')) {\n      element.classList.add('xterm-find-result-decoration');\n      if (borderColor) {\n        element.style.outline = `1px solid ${borderColor}`;\n      }\n    }\n    if (isActiveResult) {\n      element.classList.add('xterm-find-active-result-decoration');\n    }\n  }\n\n  /**\n   * Creates a decoration for the result and applies styles\n   * @param result the search result for which to create the decoration\n   * @param options the options for the decoration\n   * @returns the {@link IDecoration} or undefined if the marker has already been disposed of\n   */\n  private _createResultDecoration(result: ISearchResult, options: ISearchDecorationOptions): IDecoration | undefined {\n    const terminal = this._terminal!;\n    const marker = terminal.registerMarker(-terminal.buffer.active.baseY - terminal.buffer.active.cursorY + result.row);\n    if (!marker) {\n      return undefined;\n    }\n    const findResultDecoration = terminal.registerDecoration({\n      marker,\n      x: result.col,\n      width: result.size,\n      backgroundColor: options.matchBackground,\n      overviewRulerOptions: this._highlightedLines.has(marker.line) ? undefined : {\n        color: options.matchOverviewRuler,\n        position: 'center'\n      }\n    });\n    if (findResultDecoration) {\n      const disposables: IDisposable[] = [];\n      disposables.push(marker);\n      disposables.push(findResultDecoration.onRender((e) => this._applyStyles(e, options.matchBorder, false)));\n      disposables.push(findResultDecoration.onDispose(() => disposeArray(disposables)));\n    }\n    return findResultDecoration;\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","_listeners","_disposed","event","this","_event","listener","push","dispose","i","length","splice","fire","arg1","arg2","queue","call","undefined","clearListeners","from","to","e","disposeArray","disposables","d","_disposables","_isDisposed","register","unregister","index","indexOf","value","_value","clear","f","array","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","NON_WORD_CHARACTERS","SearchAddon","Disposable","constructor","options","super","_highlightedLines","Set","_highlightDecorations","_selectedDecoration","MutableDisposable","_linesCacheTimeoutId","_onDidChangeResults","EventEmitter","onDidChangeResults","_highlightLimit","highlightLimit","activate","terminal","_terminal","onWriteParsed","_updateMatches","onResize","toDisposable","clearDecorations","_highlightTimeout","window","clearTimeout","_cachedSearchTerm","_lastSearchOptions","decorations","setTimeout","term","findPrevious","incremental","noScroll","retainCachedSearchTerm","findNext","searchOptions","Error","_highlightAllMatches","found","_findNextAndSelect","_fireResults","searchResultsWithHighlight","prevResult","result","_find","row","col","cols","match","decoration","_createResultDecoration","add","marker","line","startRow","startCol","clearSelection","_initLinesCache","searchPosition","_findInLine","y","buffer","active","baseY","rows","prevSelectedPos","getSelectionPosition","end","x","start","_selectResult","_findPreviousAndSelect","resultIndex","selectedMatch","size","resultCount","isReverseSearch","Math","max","_linesCache","Array","_cursorMoveListener","onCursorMove","_destroyLinesCache","_resizeListener","_isWholeWord","searchIndex","includes","firstLine","getLine","isWrapped","cache","_translateBufferLineToStringWithWrap","stringLine","offsets","offset","_bufferColsToStringOffset","searchTerm","caseSensitive","toLowerCase","searchStringLine","regex","searchRegex","RegExp","foundTerm","exec","slice","lastIndex","lastIndexOf","wholeWord","startRowOffset","endRowOffset","startColOffset","endColOffset","startColIndex","_stringLengthToBufferSize","cell","getCell","char","getChars","nextCell","getWidth","lineIndex","getCode","trimRight","strings","lineOffsets","nextLine","lineWrapsToNext","string","translateToString","lastCell","join","select","registerMarker","cursorY","registerDecoration","width","backgroundColor","activeMatchBackground","layer","overviewRulerOptions","color","activeMatchColorOverviewRuler","onRender","_applyStyles","activeMatchBorder","onDispose","viewportY","scroll","floor","scrollLines","element","borderColor","isActiveResult","classList","contains","style","outline","findResultDecoration","matchBackground","has","matchOverviewRuler","position","matchBorder"],"version":3,"file":"index.e13cebba.js.map","sourceRoot":"/__parcel_source_root/"}